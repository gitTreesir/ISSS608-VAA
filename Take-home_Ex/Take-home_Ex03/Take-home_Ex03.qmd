---
title: "Take-Home Exercise 03"
author: "Ong Chae Hui"
date: 1 Jun 2023
date-modified: "`r Sys.Date()`"
execute:
  echo: true
  eval: true
  warning: false
  freeze: auto  
format: 
  html:
    code-fold: false
    code-summary: "Show the codes"
    code-overflow: wrap
    code-block-bg: true
engine: knitr
---

# 1. Overview

With reference to the [Mini-Challenge 3](https://vast-challenge.github.io/2023/MC3.html) of [VAST Challenge 2023](https://vast-challenge.github.io/2023/) and by using visual analytics to understand the patterns of groups in the knowledge graph and highlight anomalous groups.

## 1.1. The Task

1.  Use visual analytics to identify anomalies in the business groups present in the knowledge graph.

2.  Develop a visual analytics process to find similar businesses and group them. This analysis should focus on a business's most important features and present those features clearly to the user.

3.  Measure similarity of businesses that you group in the previous question. Express confidence in your groupings visually.

4.  Based on your visualizations, provide evidence for or against the case that anomalous companies are involved in illegal fishing. Which business groups should FishEye investigate further?

## 1.2. Data Source

For this task, we will make use of the *MC3.json* provided for the data analysis and visualisation.

# 2. Loading and Launching of Required R Packages

The required R library packages are being loaded. For this exercise, we will make use of the following R library packages.

-   **jsonlite**, JSON parser and generator optimized for statistical data and the web.
-   **tidygraph** provides a tidy framework for all things relational (networks/graphs, trees, etc.)
-   **ggraph**, an extension of the ggplot2 API tailored to graph visualizations and provides the same flexible approach to building up plots layer by layer.
-   **visNetwork** for network visualization.
-   **tidyverse**, a family of modern R packages specially designed to support data science, analysis and communication task including creating static statistical graphs.
-   **tidytext** for text mining and conversion of text to and from tidy formats.
-   **skimr** provides summary statistics about variables in data frames, tibbles, data tables and vectors.
-   **DT** provides an R interface to the JavaScript library DataTables that create interactive table on html page.

The code chunk below uses `pacman::p_load()` to check if the above packages are installed. If they are, they will be loaded into the R environment.

```{r}
pacman::p_load(jsonlite, tidygraph, ggraph, visNetwork, skimr,
               tidyverse, graphlayouts, ggforce, DT, tidytext)
```

# 3. Data Preparation

We will first load each of the data files into the environment and perform data wrangling.

## 3.1. Loading and Extracting the Data

Based on the VAST 2023 data notes, column `dataset` will always be 'mc3', to represent this set of data belongs to mini challenge 3. As such, we will not import this column into the R environment.

### 3.1.1. Load main file *MC3.json*

We will first load in the main file, *MC3.json*, then extract the nodes and edges (links) information out.

```{r}
mc3_data <- fromJSON("data/MC3.json")
```

#### 3.1.1.1. Extracting the nodes data.frame from MC3

We will first extract the nodes info from `mc3_data`.

```{r}
mc3_nodes <- as_tibble(mc3_data$nodes) %>%
  select(id, country, type, product_services, revenue_omu)
```

Then we will mutate the data by converting `id`, `country`, `type` and `product_services` into `character` data type, while `revenue_omu` will be converted to `numeric` data type. We will also rearrange the columns by using `select()`.

```{r}
mc3_nodes <- mc3_nodes %>%
  mutate(country = as.character(country),
         id = as.character(id),
         product_services = as.character(product_services),
         revenue_omu = as.numeric(as.character(revenue_omu)),
         type = as.character(type)) %>%
  select(id, country, type, revenue_omu, product_services)
```

#### 3.1.1.2. Extracting the edges (links) data.frame from mc3

Next, we will extract the edges info from `mc3_data`.

```{r}
mc3_edges <- as_tibble(mc3_data$links) %>%
  select(source, target, type)
```

Then we will mutate the data by converting `source`, `target` and `type` into `character` data type. At the same time, we will compute the weights of the edges.

```{r}
mc3_edges <- mc3_edges %>%
  distinct() %>%
  mutate(source = as.character(source),
         target = as.character(target), 
         type = as.character(type)) %>%
  group_by(source, target, type) %>%
  summarise(weights = n()) %>%
  filter(source != target) %>%
  ungroup()
```

#### 3.1.1.3. Examining the structure of *mc3_edges*

```{r}
skim(mc3_edges)
```

::: {.callout-note title="Examination of the data structure"}
The report above reveals that there is no missing values in all fields in `mc3_edges`.

However, the `source` field has a maximum value of 700 (in lexicographic order), which seemed a little to lengthy, as compared to the `target` field which only has a maximum value of 28. With that, we will take a closer look at the data under the `source` field.
:::

#### 3.1.1.4. Examining the data distribution of *mc3_edges*

[**Source Field**]{.underline}

We will take a closer look at the `source` field to investigate the reason of having a maximum value of 700 by counting the frequency of each unique value and take a peep of the actual value by listing the first 20 records to detect any anomalies in the data. We will list the string values in descending order based on its frequency.

```{r}
mc3_edges_source_freq <- mc3_edges %>%
  group_by(source) %>%
  summarise(freq_cnt = n()) %>%
  arrange(desc(freq_cnt)) %>%
  ungroup()

head(mc3_edges_source_freq, 20)
```

::: {.callout-note title="Examination of the 'source' field"}
The results revealed that there were lists (denoted by `c(`) embedded within the `source` field, as indicated in the screenshot below.

![](images/img1_mc3_edges_source.png){fig-align="center" width="440"}

We will have to break these lists further into single values before deriving the weight of the edges.
:::

Firstly, we will have to extract all the records that contain an embedded list in the `source` field. We will make use of the `substr()` method to identify these records.

```{r}
mc3_edges_list_in_source <- mc3_edges %>%
  filter(substr(source, 1, 2) %in% "c(") %>%
  ungroup()

mc3_edges_list_in_source
```

::: {.callout-note title="Examination of type field"}
A total of 2,169 records were found to contain embedded list of entities in the `source` field. We will have to break up the individual list using `unnest()` and put these individual entities into the source field.
:::

[**Break up the Individual List**]{.underline}

The following code chunk will break up the individual list using `unnest()` and put these individual entities into the source field.

We will also remove:

-   leading/trailing whitespace and empty values using `trimws()`
-   double quotes using `gsub()`
-   values that only contain the character, `c`

We will then recompute the weights based on the extracted entities, grouping them by source, target and type.

```{r}
# Break up values containing lists using unnest().
# It will split the string when it encounters the open parenthesis "(",
# comma "," and close parenthesis ")" 
broken_source <- unnest(mc3_edges_list_in_source, 
                        source = strsplit(as.character(source),
                                          "\\(|\\,|\\)"))

# Remove leading/trailing whitespace and also filter records with only
# the character "c" as the source
broken_source <- broken_source %>%
  mutate(source = gsub("\"", "", source)) %>%
  filter(source != "c") %>%
  mutate(source = trimws(source)) %>%
  mutate(target = trimws(target)) %>%
  group_by(source, target, type) %>%
  summarise(weights = n()) %>%
  filter(source != target) %>%
  distinct() %>%
  ungroup()
```

[**Combining the list of entries with the rest of the mc3_edges**]{.underline}

Now that we have extracted the list of entities (`broken_source`), we will combine the list with mc3_edges that do not have the embedded list (i.e. `mc3_edges_nolist`) and study the data.

In order to create `mc3_edges_nolist`, we will make use of `filter()` and `substr()` to identify those records that do not start with `"c("`. this will help to filter off those records that have the embedded list in the source field.

Once we combine the 2 lists, we will do a thorough cleaning to ensure that there is no leading/trailing white spaces in all the 3 fields by using `trimws()`. At the same time, we will remove any duplicate records present and arrange the list in descending order based on the `weights` field.

```{r}
# Extract the list of records without the embedded list in source field
mc3_edges_nolist <- mc3_edges %>%
  filter(!substr(source, 1, 2) %in% "c(") %>%
  distinct() %>%
  ungroup()

# Merge the extracted entities (broken_source) to the list
combined_mc3_edges <- rbind(mc3_edges_nolist, broken_source) 

# Clean up the combined list
combined_mc3_edges <- combined_mc3_edges %>%
  mutate(source = trimws(source)) %>%
  mutate(target = trimws(target)) %>%
  mutate(type = trimws(type)) %>%
  group_by(source, target, type) %>%
  filter(source != target) %>%
  distinct() %>%
  arrange(desc(weights)) %>%
  ungroup()

datatable(combined_mc3_edges,
          class="stripe",
          caption = "\nTable 1: List of Entities\n",
          colnames = c("Source", "Target", "Type", "Weights"),
          options = list(
            columnDefs = list(list(className = 'dt-center',
                                   targets="_all"))))
```

::: {.callout-note title="Observations from Table 1"}
Table 1 revealed that there are some of the individuals have multiple linkages to the same company, which we will need to probe further in order to understand the underlying relationships.

In addition, we also noticed that there are some individuals that included salutations (i.e. `Dr.`, `Mr.`, `Ms.` and `Mrs.`), as part of their names. As part of the data cleaning, we will remove these salutations from their names before proceeding with any data analysis. 
:::

[**Removing the Salutations in target field**]{.underline}

As mentioned in the observations from Table 1 above, we will proceed to remove the salutations (i.e. `Dr.`, `Mr.`, `Ms.` and `Mrs.`) from the names of the `target` field by using `gsub()`. 

```{r}
## Remove Salutations

# combined_mc3_edges$target <- 
#   gsub("Mr\\.\\s|Dr\\.\\s|Mrs\\.\\s|Ms\\.\\s", "",
#        combined_mc3_edges$target)

```

#### 3.1.1.5. Understanding the Beneficial Owner and Company Contacts

In this section, we will find out the number of companies each individual person is linked with, i.e. the number of companies in which an individual is a Beneficial Owner; and the number of companies in which an individual is a Company Contact.

```{r}
# Derive the number of companies a person is linked
combined_mc3_edges_coy_count <- combined_mc3_edges %>%
  group_by(target, type) %>%  
  summarise(coy_count = n()) %>%
  distinct() %>%
  arrange(desc(coy_count)) %>%
  ungroup()


datatable(combined_mc3_edges_coy_count,
          class="stripe",
          caption = "\nTable 2: List of Entities\n",
          colnames = c("Target", "Type", "Company Count"),
          options = list(
            columnDefs = list(list(className = 'dt-center',
                                   targets="_all"))))
```

::: {.callout-note title="Analysis from Table 2"}
From Table 2 above, it confirms that some of the individuals are Beneficial Owners or Company Contacts of multiple companies. We will investigate further into these individuals and the companies that they are in contact with in our analysis.
:::




The following charts presents the distribution of the above data, by the type of role that an individual plays in the Company (i.e. Beneficial Owner or Company Contact).

::: panel-tabset
### Number of Companies a Person Owns

```{r}
# Get the count of the records in each bin
combined_mc3_edges_bo_gp <- combined_mc3_edges_coy_count %>%
  group_by(coy_count) %>%
  filter(type == "Beneficial Owner") %>%
  summarise(bo_cnt = n())

# Create a distribution with bar chart using ggplot2
plot_bo_cnt <- ggplot(combined_mc3_edges_bo_gp, 
                      aes(x = coy_count, y = bo_cnt)) +
  geom_bar(stat = "identity", fill = "deepskyblue3") +
  geom_text(aes(label = bo_cnt), vjust = -0.5, color = "black") +
  labs(x = "\nCompany Count", y = "Count\n", 
       title = "Number of Companies a Person Owns") +
  ylim(0,14000) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5)) +
  scale_x_continuous(breaks = unique(combined_mc3_edges_bo_gp$coy_count))

plot_bo_cnt
```

### Number of Companies a Person is Contact

```{r}
combined_mc3_edges_cc_gp <- combined_mc3_edges_coy_count %>%
  group_by(coy_count) %>%
  filter(type == "Company Contacts") %>%
  summarise(cc_cnt = n())

# Create a distribution with bar chart using ggplot2
plot_cc_cnt <- ggplot(combined_mc3_edges_cc_gp, 
                      aes(x = coy_count, y = cc_cnt)) +
  geom_bar(stat = "identity", fill = "deepskyblue3") +
  geom_text(aes(label = cc_cnt), vjust = -0.5, color = "black") +
  labs(x = "\nCompany Count", y = "Count\n", 
       title = "Number of Companies where Person is Contact") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5)) +
  scale_x_continuous(breaks = unique(combined_mc3_edges_cc_gp$coy_count))

plot_cc_cnt
```
:::

::: {.callout-note title="Findings from the 2 plots"}
[**Findings from first plot - "Number of Companies a Person Owns"**]{.underline}

It was revealed that even though majority of the Beneficial Owners own one company, there are still a number of individuals owning more than 5 companies.

[**Findings from second plot - "Number of Companies a Person is Contact"**]{.underline}

It showed that majority of the individiuals are contacts for one company. It was revealed some of these individuals are company contacts of more than 4 companies.

We will investigate further on these individuals and their respective companies in the subsequent analysis.
:::

#### 3.1.1.6. Consolidating the list of Companies with reference to the Individuals with multiple companies

From the analysis results above, we will extract out the respective companies that these individuals are involved in. Then we will gather the company information from *mc3_nodes*.

We will perform the following steps to get the list of unique companies:

-   Retrieve the list of companies from `combined_mc3_edges_coy_count` for those individuals who owns more than 5 companies, using the `filter()`.
-   Retrieve the list of companies from `combined_mc3_edges_coy_count` for those individuals who are contacts for more than 4 companies, using the `filter()`.
-   Combine both the above lists by extracting out the matching records from the `combined_mc3_edges` dataframe.

```{r}
bo_above_5 <- combined_mc3_edges_coy_count %>%
  filter(type == "Beneficial Owner" & coy_count >= 5) 

cc_above_4 <- combined_mc3_edges_coy_count %>%
  filter(type == "Company Contacts" & coy_count >= 4)

# Combining the list of companies are linked to the individuals
combined_mc3_sources <- combined_mc3_edges %>%
  filter(target %in% bo_above_5$target == TRUE |
           target %in% cc_above_4$target == TRUE) %>%
  distinct()
```

Once we have the unique list of companies, we will then form the nodes dataframe.

[**Design Consideration**]{.underline}

In order to easily identify whether a node is a Company, Beneficial Owner or Company Contacts, we will include a `group` attribute in the nodes dataframe. We will make use of `case_when()` functions to build the conditions in determining the value of `group` for each node. The conditions are as follows:

-   If the `id` can be found in the `source` field of `combined_mc3_sources`, then the node is a Company (i.e. group = "Company")
-   Otherwise, if the `id` is found in the `target` field of `combined_mc3_sources`, we will then need to check the `type` field of `combined_mc3_sources` to determine whether the node is Beneficial Owner or Company Contacts.

```{r}
# Forming the nodes from the combined_sources
id1 <- combined_mc3_sources %>%
  select(source) %>%
  rename(id = source)

id2 <- combined_mc3_sources %>%
  select(target) %>%
  rename(id = target)

# create a new nodes data table derived from the source and target of edge data. This would ensure that only nodes with connections will be included.
mc3_nodes_combined <- rbind(id1, id2) %>%
  distinct()

# Adding a group attribute, into the nodes dataframe, to differentiate whether the node is a Company, Beneficial Owner or Company Contacts. 
# mc3_nodes_combined <- mc3_nodes_combined %>%
#   mutate( group = case_when(
#     id %in% combined_mc3_sources$source ~ "Company",
#     id %in% combined_mc3_sources$target & combined_mc3_sources$type == "Beneficial Owner" ~ "Beneficial Owner",
#       TRUE ~ "Company Contacts"
#     )
#   )


mc3_nodes_combined <- mc3_nodes_combined %>%
  mutate( group = case_when(
    id %in% combined_mc3_sources$source ~ "Company",
    id %in% bo_above_5$target ~ "Beneficial Owner",
    id %in% cc_above_4$target ~ "Company Contacts"
    )
  )

```

# 4. Data Exploration & Visualisation

We will build up the `tbl_graph` object in preparation to visualise the Company-Individual Relationship. 
```{r}
# Build tbl_graph using the valid nodes and edges 
mc3_graph <- tbl_graph(nodes = mc3_nodes_combined,
                       edges = combined_mc3_sources,
                       directed = FALSE)

# Renaming the id column to label and
# create a new column, id with the row_number()
mc3_graph <- mc3_graph %>%
  activate(nodes) %>%
  rename(label = id) %>%
  mutate(id=row_number())

# Converting the nodes with the centrality measures into a tibble dataframe
nodes_df <- mc3_graph %>%
  activate(nodes) %>%
  as_tibble() 

# Converting the edges into a tibble dataframe
edges_df <- mc3_graph %>%
  activate(edges) %>%
  as_tibble()
```


## 4.1. Visualisation of the Company-Individual Relationship

[**Design Consideration**]{.underline}

We will make use of the `group` attribute that we created in the earlier section to clearly identify the different types of nodes (Company, Beneficial Owner, Company Contacts).

Mouse pointer hover action is also included on the graph so that the user can hover the mouse pointer over the graph to look at the possible different ‘groups’ of connectivity.

```{r}
# Preparing the data for visualisation
nodes <- nodes_df %>%
  filter(id %in% c(edges_df$from, edges_df$to)) %>%
  arrange(label) 

# Building the network graph using visNetwork package
vis_nw <- visNetwork(nodes, edges_df,
                     main = "An Overview of the Company-Individual Relationship") %>%
  visIgraphLayout(layout = "layout_with_fr") %>%
  visLayout(randomSeed = 1234) %>%
  visNodes(size = 30) %>%
  visOptions(highlightNearest = list(enabled = T, degree = 2, hover = T),
             nodesIdSelection = TRUE) %>%
  visLegend(width = 0.1, position = "right", main = "group") %>%  
  visEdges(smooth = list(enabled = TRUE, type = "curvedCW"))

vis_nw
```

::: {.callout-note title="Observations"}
The network graph above revealed:

1.    There are 4 individuals 

:::





```{r}
# Getting the nodes info from mc3_nodes
# mc3_nodes_company <- 
#   subset(mc3_nodes, 
#          id %in% combined_sources$source) %>%
#   distinct()
```

#### 3.1.1.5 Forming the various nodes data frames

We will now form the various nodes data frame based on the info from `combined_mc3_edges`.

```{r}
# Forming the Company Nodes Data Frame

# Extract the unique list of source (i.e. company) from combined_mc3_edges
unique_source_from_combined_mc3_edges <- unique(combined_mc3_edges$source)

mc3_nodes_company <- subset(mc3_nodes, 
                            id %in% unique_source_from_combined_mc3_edges)
  
mc3_nodes_company <- mc3_nodes_company %>%
  distinct()

mc3_nodes_company
```

```{r}
# Forming the Beneficial Owner Nodes Data Frame

# Extract the unique list of source (i.e. Beneficial Owner) from combined_mc3_edges
bo_df_from_combined_mc3_edges <- combined_mc3_edges %>%
  filter(type == "Beneficial Owner") 

unique_bo_from_combined_mc3_edges <- 
  unique(bo_df_from_combined_mc3_edges$target) 


mc3_nodes_bo <- subset(mc3_nodes,
                       id %in%
                         unique_bo_from_combined_mc3_edges)

mc3_nodes_bo
```

```{r}
# Forming the Company Contacts Nodes Data Frame

# Extract the unique list of source (i.e. Company Contacts) from combined_mc3_edges
cc_df_from_combined_mc3_edges <- combined_mc3_edges %>%
  filter(type == "Company Contacts") 

unique_cc_from_combined_mc3_edges <- 
  unique(cc_df_from_combined_mc3_edges$target) 

mc3_nodes_cc <- subset(mc3_nodes,
                       id %in%
                         cc_df_from_combined_mc3_edges)

mc3_nodes_cc
```

```{r}
id1 <- combined_mc3_edges %>%
  select(source) %>%
  rename(id = source)
id2 <- combined_mc3_edges %>%
  select(target) %>%
  rename(id = target)

# create a new nodes data table derived from the source and target of edge data. This would ensure that only nodes with connections will be included.

mc3_nodes_extracted <- rbind(id1, id2) %>%
  distinct()
```

[**Type Field**]{.underline}

We will then look at the distribution of the `type` in the new `combined_mc3_edges`.

[Design Considerations]{.underline}

The count for each type will be displayed at the top of the bar for easy reference.

::: panel-tabset
### Distribution of Type Field

```{r}
#| echo: false

# Get the count of the records in each bin
combined_mc3_edges_gp <- combined_mc3_edges %>%
  group_by(type) %>%
  summarise(cnt = n())

# Create a distribution with bar chart using ggplot2
plot_type <- ggplot(combined_mc3_edges_gp, aes(x = type, y = cnt)) +
  geom_bar(stat = "identity", fill = "deepskyblue3") +
  geom_text(aes(label = cnt), vjust = -0.5, color = "black") +
  labs(x = "\nType", y = "Count\n", 
       title = "Distribution of Type Field") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5)) 

plot_type
```

### Code Chunk

```{r}
#| eval: false
#| code-fold: false

# Get the count of the records in each bin
combined_mc3_edges_gp <- combined_mc3_edges %>%
  group_by(type) %>%
  summarise(cnt = n())

# Create a distribution with bar chart using ggplot2
plot_type <- ggplot(combined_mc3_edges_gp, aes(x = type, y = cnt)) +
  geom_bar(stat = "identity", fill = "deepskyblue3") +
  geom_text(aes(label = cnt), vjust = -0.5, color = "black") +
  labs(x = "\nType", y = "Count\n", 
       title = "Distribution of Type Field") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5)) 

plot_type
```
:::

::: {.callout-tip title="Examination of Type field"}
From the above chart, we noticed that there are 2 types of roles presented in the data: `Beneficial Owner` (17,303 records) and `Company Contacts` (7,628 records).
:::

#### 3.1.1.5. Examining the structure of *mc3_nodes* data.frames using `skim()` of **skimr** package.

```{r}
skim(mc3_nodes)
```

::: {.callout-tip title="Examination of the data structure"}
The report above reveals that there are 21,515 missing values in `revenue_omu` under `mc3_nodes`.
:::

#### 3.1.1.6. Examining the data distribution of *mc3_nodes*

```{r}
ggplot(data = mc3_nodes,
       aes(x = type)) +
  geom_bar()

```

::: {.callout-tip title="Examination of the data structure"}
From the above chart, we noticed that there are 3 types of roles presented in the `mc3_nodes` dataset: `Beneficial Owner`, `Company` and `Company Contacts`.
:::

## 3.2. Initial Network Visualisation & Analysis

### 3.2.1. Building network model with tidygraph

```{r}
id1 <- mc3_edges %>%
  select(source) %>%
  rename(id = source)
id2 <- mc3_edges %>%
  select(target) %>%
  rename(id = target)
mc3_nodes1 <- rbind(id1, id2) %>%
  distinct() 
# %>%
#   left_join(mc3_nodes,
#             unmatched = "drop")
```

```{r}
mc3_graph <- tbl_graph(nodes = mc3_nodes1,
                       edges = mc3_edges,
                       directed = FALSE) %>%
  mutate(betweenness_centrality = centrality_betweenness(),
         closeness_centrality = centrality_closeness())
```

```{r}
mc3_graph %>%
  filter(betweenness_centrality >= 100000) %>%
ggraph(layout = "fr") +
  geom_edge_link(aes(alpha=0.5)) +
  geom_node_point(aes(
    size = betweenness_centrality,
    colors = "lightblue",
    alpha = 0.5)) +
  scale_size_continuous(range=c(1,10))+
  theme_graph()

```

## 3.3 TEXT SENSING with tidytext

### 3.3.1. Word Count

We will fist calculate the number of times the word `fish` appeared in the field product_services.

```{r}
# mc3_nodes %>% 
#     mutate(n_fish = str_count(product_services, "fish")) 
```

### 3.2.2. Tokenisation

We will use `unnest_token()` of **tidytext** to split text in product_services field into words. By default, punctuation has been stripped and the tokens will be converted to lowercase before comparison.

```{r}
# This is a very basic code of unnest_token()
# tidy_nodes <- mc3_nodes %>%
#   unnest_tokens(word,
#                 product_services)
```

We will then visualise the words extracted.

```{r}
# tidy_nodes %>%
#   count(word, sort = TRUE) %>%
#   top_n(15) %>%
#   mutate(word = reorder(word, n)) %>%
#   ggplot(aes(x = word, y = n)) +
#   geom_col() +
#   xlab(NULL) +
#   coord_flip() +
#       labs(x = "Count",
#       y = "Unique words",
#       title = "Count of unique words found in product_services field")
```

The bar chart reveals that the unique words contains some words that may not be useful to use. For instance "a" and "to". In the word of text mining we call those words stop words. We will remove these words from the analysis as they are fillers used to compose a sentence.

In addition, there is also a high number of the words `character`, `0`, `unknown`, `products`, `including`, `services`, `related`, `materials`, `equipment`, `accessories`, `frozen`, `systems`, `freight`, `industrial`, `processing`, `offers`, `machines`, `canned`, `transportation`, `logistics`, `supplies`, `range` which are not representative of the products_services field. Hence, we will add them into the `stop_words` dataset in **tidytext** so that they can be filtered out.

### 3.2.4. Adding stop words into the tidytext `stop_words` dataset

```{r}
# Retrieve the current stop_words dataset
# data(stop_words)

# Create a vector containing the additional stop words
# additional_stop_words <- c("NA", "character", "0", "unknown", "products",
#                            "including", "services", "related", "materials",
#                            "equipment", "accessories", "frozen", "systems",
#                            "freight", "industrial", "processing", "offers",
#                            "machines", "canned", "transportation", "logistics",
#                            "supplies", "range")

# Add the additional stop words to the stop_words dataset and remove any duplicate entries
# stop_words <- bind_rows(stop_words, tibble(word = additional_stop_words)) 
# stop_words <- distinct(stop_words)

```

NOTE: - there are also `NA` for revenue_omu field - Beneficial Owner will be linked to Company; Company Contacts will be linked to Company. Technically, there should not be any linkages between Beneficial Owner and Company Contacts.

### 3.2.5. Removing stop words

```{r}
# tidy_nodes_no_stopwords <- tidy_nodes %>%
#   anti_join(stop_words)
```

We can then visualise the words after removing the stop words.

```{r}
# tidy_nodes_no_stopwords %>%
#   count(word, sort = TRUE) %>%
#   top_n(15) %>%
#   mutate(word = reorder(word, n)) %>%
#   ggplot(aes(x = word, y = n)) +
#   geom_col() +
#   xlab(NULL) +
#   coord_flip() +
#       labs(x = "Count",
#       y = "Unique words",
#       title = "Count of unique words found in product_services field")
```

```{r}
# This is more sophisticated to sift out the data
# tidy_nodes <- mc3_nodes %>%
#   unnest_tokens(word, product_services,
#                 to_lower = TRUE,      # convert all the lowercase before comparison
#                 strip_punct = TRUE)   # exclude all the punctuation 
```

```{r}
#| eval: false
### Exporting to CSV for closer examination
# write_csv(x = tidy_nodes_no_stopwords,
#           "data/generated/tidy_nodes_no_stopwords.csv")
# write_csv(x = mc3_nodes, "data/generated/mc3_nodes.csv")
#  write_csv(x = mc3_edges, "data/generated/mc3_edges.csv")
# 
# write_rds(mc3_nodes, "data/generated/mc3_nodes.rds")
# write_rds(mc3_edges, "data/generated/mc3_edges.rds")
# 
# read_mc3_nodes <- read_rds("data/generated/mc3_nodes.rds")
# read_mc3_edges <- read_rds("data/generated/mc3_edges.rds")
```
