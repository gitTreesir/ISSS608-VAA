---
title: "Take-Home Exercise 03"
author: "Ong Chae Hui"
date: 1 Jun 2023
date-modified: "`r Sys.Date()`"
execute:
  echo: true
  eval: true
  warning: false
  freeze: auto  
format: 
  html:
    code-fold: false
    code-summary: "Show the codes"
    code-overflow: wrap
    code-block-bg: true
engine: knitr
---

# 1. Overview

With reference to the [Mini-Challenge 3](https://vast-challenge.github.io/2023/MC3.html) of [VAST Challenge 2023](https://vast-challenge.github.io/2023/) and by using visual analytics to understand the patterns of groups in the knowledge graph and highlight anomalous groups.

## 1.1. The Task

1.  Use visual analytics to identify anomalies in the business groups present in the knowledge graph.

2.  Develop a visual analytics process to find similar businesses and group them. This analysis should focus on a business's most important features and present those features clearly to the user.

3.  Measure similarity of businesses that you group in the previous question. Express confidence in your groupings visually.

4.  Based on your visualizations, provide evidence for or against the case that anomalous companies are involved in illegal fishing. Which business groups should FishEye investigate further?

## 1.2. Data Source

For this task, we will make use of the *MC3.json* provided for the data analysis and visualisation.

# 2. Loading and Launching of Required R Packages

The required R library packages are being loaded. For this exercise, we will make use of the following R library packages.

-   **jsonlite**, JSON parser and generator optimized for statistical data and the web.
-   **tidygraph** provides a tidy framework for all things relational (networks/graphs, trees, etc.)
-   **ggraph**, an extension of the ggplot2 API tailored to graph visualizations and provides the same flexible approach to building up plots layer by layer.
-   **visNetwork** for network visualization.
-   **tidyverse**, a family of modern R packages specially designed to support data science, analysis and communication task including creating static statistical graphs.
-   **tidytext** for text mining and conversion of text to and from tidy formats.
-   **skimr** provides summary statistics about variables in data frames, tibbles, data tables and vectors.
-   **DT** provides an R interface to the JavaScript library DataTables that create interactive table on html page.
-   **treemap**
-   **plotly**

The code chunk below uses `pacman::p_load()` to check if the above packages are installed. If they are, they will be loaded into the R environment.

```{r}
pacman::p_load(jsonlite, tidygraph, ggraph, visNetwork, skimr,
               tidyverse, graphlayouts, ggforce, DT, tidytext,
               treemap, treemapify, plotly)
```

# 3. Data Preparation

We will first load each of the data files into the environment and perform data wrangling.

## 3.1. Loading and Extracting the Data

Based on the VAST 2023 data notes, column `dataset` will always be 'mc3', to represent this set of data belongs to mini challenge 3. As such, we will not import this column into the R environment.

### 3.1.1. Load main file *MC3.json*

We will first load in the main file, *MC3.json*, then extract the nodes and edges (links) information out.

```{r}
mc3_data <- fromJSON("data/MC3.json")
```

#### 3.1.1.1. Extracting the nodes data.frame from MC3

We will first extract the nodes info from `mc3_data`.

```{r}
mc3_nodes_raw <- as_tibble(mc3_data$nodes) %>%
  select(id, country, type, product_services, revenue_omu)
```

Then we will mutate the data by converting `id`, `country`, `type` and `product_services` into `character` data type, while `revenue_omu` will be converted to `numeric` data type. We will also rearrange the columns by using `select()`.

```{r}
mc3_nodes_raw <- mc3_nodes_raw %>%
  mutate(country = as.character(country),
         id = as.character(id),
         product_services = as.character(product_services),
         revenue_omu = as.numeric(as.character(revenue_omu)),
         type = as.character(type)) %>%
  select(id, country, type, revenue_omu, product_services)
```

#### 3.1.1.2. Extracting the edges (links) data.frame from mc3

Next, we will extract the edges info from `mc3_data`.

```{r}
mc3_edges_raw <- as_tibble(mc3_data$links) %>%
  select(source, target, type)
```

Then we will mutate the data by converting `source`, `target` and `type` into `character` data type. At the same time, we will compute the weights of the edges.

```{r}
mc3_edges_raw <- mc3_edges_raw %>%
  distinct() %>%
  mutate(source = as.character(source),
         target = as.character(target), 
         type = as.character(type)) %>%
  group_by(source, target, type) %>%
  summarise(weights = n()) %>%
  filter(source != target) %>%
  ungroup()
```

#### 3.1.1.3. Examining the structure of *mc3_edges_raw*

```{r}
skim(mc3_edges_raw)
```

::: {.callout-note title="Examination of the data structure"}
The report above reveals that there is no missing values in all fields in `mc3_edges_raw`.

However, the `source` field has a maximum value of 700 (in lexicographic order), which seemed a little to lengthy, as compared to the `target` field which only has a maximum value of 28. With that, we will take a closer look at the data under the `source` field.
:::

#### 3.1.1.4. Examining the data distribution of *mc3_edges_raw*

[**Source Field**]{.underline}

We will take a closer look at the `source` field to investigate the reason of having a maximum value of 700 by counting the frequency of each unique value and take a peep of the actual value by listing the first 20 records to detect any anomalies in the data. We will list the string values in descending order based on its frequency.

```{r}
mc3_edges_source_freq <- mc3_edges_raw %>%
  group_by(source) %>%
  summarise(freq_cnt = n()) %>%
  arrange(desc(freq_cnt)) %>%
  ungroup()

head(mc3_edges_source_freq, 20)
```

::: {.callout-note title="Examination of the 'source' field"}
The results revealed that there were lists (denoted by `c(`) embedded within the `source` field, as indicated in the screenshot below.

![](images/img1_mc3_edges_source.png){fig-align="center" width="440"}

We will have to break these lists further into single values before deriving the weight of the edges.
:::

Firstly, we will have to extract all the records that contain an embedded list in the `source` field. We will make use of the `substr()` method to identify these records.

```{r}
mc3_edges_list_in_source <- mc3_edges_raw %>%
  filter(substr(source, 1, 2) %in% "c(") %>%
  ungroup()

mc3_edges_list_in_source
```

::: {.callout-note title="Examination of type field"}
A total of 2,169 records were found to contain embedded list of entities in the `source` field. We will have to break up the individual list using `unnest()` and put these individual entities into the source field.
:::

[**Break up the Individual List**]{.underline}

The following code chunk will break up the individual list using `unnest()` and put these individual entities into the source field.

We will also remove:

-   leading/trailing whitespace and empty values using `trimws()`
-   double quotes using `gsub()`
-   values that only contain the character, `c`

We will then recompute the weights based on the extracted entities, grouping them by source, target and type.

```{r}
# Break up values containing lists using unnest().
# It will split the string when it encounters the open parenthesis "(",
# comma "," and close parenthesis ")" 
broken_source <- unnest(mc3_edges_list_in_source, 
                        source = strsplit(as.character(source),
                                          "\\(|\\,|\\)"))

# Remove leading/trailing whitespace and also filter records with only
# the character "c" as the source
broken_source <- broken_source %>%
  mutate(source = gsub("\"", "", source)) %>%
  filter(source != "c") %>%
  mutate(source = trimws(source)) %>%
  mutate(target = trimws(target)) %>%
  group_by(source, target, type) %>%
  summarise(weights = n()) %>%
  filter(source != target) %>%
  distinct() %>%
  ungroup()
```

[**Combining the list of entries with the rest of the mc3_edges_raw**]{.underline}

Now that we have extracted the list of entities (`broken_source`), we will combine the list with `mc3_edges_raw` that do not have the embedded list (i.e. `mc3_edges_nolist`) and study the data.

In order to create `mc3_edges_nolist`, we will make use of `filter()` and `substr()` to identify those records that do not start with `"c("`. this will help to filter off those records that have the embedded list in the source field.

Once we combine the 2 lists, we will do a thorough cleaning to ensure that there is no leading/trailing white spaces in all the 3 fields by using `trimws()`. At the same time, we will remove any duplicate records present and arrange the list in descending order based on the `weights` field.

```{r}
# Extract the list of records without the embedded list in source field
mc3_edges_nolist <- mc3_edges_raw %>%
  filter(!substr(source, 1, 2) %in% "c(") %>%
  distinct() %>%
  ungroup()

# Merge the extracted entities (broken_source) to the list
combined_mc3_edges <- rbind(mc3_edges_nolist, broken_source) 

# Clean up the combined list
combined_mc3_edges <- combined_mc3_edges %>%
  mutate(source = trimws(source)) %>%
  mutate(target = trimws(target)) %>%
  mutate(type = trimws(type)) %>%
  group_by(source, target, type) %>%
  filter(source != target) %>%
  distinct() %>%
  arrange(desc(weights)) %>%
  ungroup()

datatable(combined_mc3_edges,
          class="stripe",
          caption = "\nTable 1: List of Entities\n",
          colnames = c("Source", "Target", "Type", "Weights"),
          options = list(
            columnDefs = list(list(className = 'dt-center',
                                   targets="_all"))))
```

::: {.callout-note title="Observations from Table 1"}
Table 1 revealed that there are some of the individuals have multiple linkages to the same company, which we will need to probe further in order to understand the underlying relationships.

In addition, we also noticed that there are some individuals that included salutations (i.e. `Dr.`, `Mr.`, `Ms.` and `Mrs.`), as part of their names. As part of the data cleaning, we will remove these salutations from their names before proceeding with any data analysis.
:::

[**Removing the Salutations in target field**]{.underline}

As mentioned in the observations from Table 1 above, we will proceed to remove the salutations (i.e. `Dr.`, `Mr.`, `Ms.` and `Mrs.`) from the names of the `target` field by using `gsub()`.

```{r}
## Remove Salutations

# combined_mc3_edges$target <- 
#   gsub("Mr\\.\\s|Dr\\.\\s|Mrs\\.\\s|Ms\\.\\s", "",
#        combined_mc3_edges$target)

```

#### 3.1.1.5. Understanding the Beneficial Owner and Company Contacts

In this section, we will find out the number of companies each individual person is linked with, i.e. the number of companies in which an individual is a Beneficial Owner; and the number of companies in which an individual is a Company Contact.

```{r}
# Derive the number of companies a person is linked
combined_mc3_edges_coy_count <- combined_mc3_edges %>%
  group_by(target, type) %>%  
  summarise(coy_count = n()) %>%
  distinct() %>%
  arrange(desc(coy_count)) %>%
  ungroup()


datatable(combined_mc3_edges_coy_count,
          class="stripe",
          caption = "\nTable 2: List of Entities\n",
          colnames = c("Target", "Type", "Company Count"),
          options = list(
            columnDefs = list(list(className = 'dt-center',
                                   targets="_all"))))
```

::: {.callout-note title="Analysis from Table 2"}
From Table 2 above, it confirms that some of the individuals are Beneficial Owners or Company Contacts of multiple companies. We will investigate further into these individuals and the companies that they are in contact with in our analysis.
:::

The following charts presents the distribution of the above data, by the type of role that an individual plays in the Company (i.e. Beneficial Owner or Company Contact).

::: panel-tabset
### Number of Companies a Person Owns

```{r}
# Get the count of the companies that a person own
combined_mc3_edges_bo_gp <- combined_mc3_edges_coy_count %>%
  group_by(coy_count) %>%
  filter(type == "Beneficial Owner") %>%
  summarise(bo_cnt = n())

# Create a distribution with bar chart using ggplot2
plot_bo_cnt <- ggplot(combined_mc3_edges_bo_gp, 
                      aes(x = coy_count, y = bo_cnt)) +
  geom_bar(stat = "identity", fill = "deepskyblue3") +
  geom_text(aes(label = bo_cnt), vjust = -0.5, color = "black") +
  labs(x = "\nCompany Count", y = "Count\n", 
       title = "Number of Companies a Person Owns") +
  ylim(0,14000) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5)) +
  scale_x_continuous(breaks = unique(combined_mc3_edges_bo_gp$coy_count))

plot_bo_cnt
```

### Number of Companies a Person is Contact

```{r}
# Get the count of the companies that a person is a company contact
combined_mc3_edges_cc_gp <- combined_mc3_edges_coy_count %>%
  group_by(coy_count) %>%
  filter(type == "Company Contacts") %>%
  summarise(cc_cnt = n())

# Create a distribution with bar chart using ggplot2
plot_cc_cnt <- ggplot(combined_mc3_edges_cc_gp, 
                      aes(x = coy_count, y = cc_cnt)) +
  geom_bar(stat = "identity", fill = "deepskyblue3") +
  geom_text(aes(label = cc_cnt), vjust = -0.5, color = "black") +
  labs(x = "\nCompany Count", y = "Count\n", 
       title = "Number of Companies where Person is Contact") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5)) +
  scale_x_continuous(breaks = unique(combined_mc3_edges_cc_gp$coy_count))

plot_cc_cnt
```
:::

::: {.callout-note title="Findings from the 2 plots"}
[**Findings from first plot - "Number of Companies a Person Owns"**]{.underline}

It was revealed that even though majority of the Beneficial Owners own one company, there are still a number of individuals owning more than 5 companies.

[**Findings from second plot - "Number of Companies a Person is Contact"**]{.underline}

It showed that majority of the individiuals are contacts for one company. It was revealed some of these individuals are company contacts of more than 4 companies.

We will investigate further on these individuals and their respective companies in the subsequent analysis.
:::

#### 3.1.1.6. Consolidating the list of Companies with reference to the Individuals with multiple companies

From the analysis results above, we will extract out the respective companies that these individuals are involved in. Then we will gather the company information from *mc3_nodes_raw*.

We will perform the following steps to get the list of unique companies:

-   Retrieve the list of companies from `combined_mc3_edges_coy_count` for those individuals who owns more than 5 companies, using the `filter()`.
-   Retrieve the list of companies from `combined_mc3_edges_coy_count` for those individuals who are contacts for more than 4 companies, using the `filter()`.
-   Combine both the above lists by extracting out the matching records from the `combined_mc3_edges` dataframe.

```{r}
bo_above_5 <- combined_mc3_edges_coy_count %>%
  filter(type == "Beneficial Owner" & coy_count >= 5) 

cc_above_4 <- combined_mc3_edges_coy_count %>%
  filter(type == "Company Contacts" & coy_count >= 4)

# Combining the list of companies are linked to the individuals
combined_mc3_sources <- combined_mc3_edges %>%
  filter(target %in% bo_above_5$target == TRUE |
           target %in% cc_above_4$target == TRUE) %>%
  distinct()
```

Once we have the unique list of companies, we will then form the nodes dataframe.

[**Design Consideration**]{.underline}

In order to easily identify whether a node is a Company, Beneficial Owner or Company Contacts, we will include a `group` attribute in the nodes dataframe. We will make use of `case_when()` functions to build the conditions in determining the value of `group` for each node. The conditions are as follows:

-   If the `id` can be found in the `source` field of `combined_mc3_sources`, then the node is a Company (i.e. group = "Company")
-   Otherwise, if the `id` is found in the `target` field of `combined_mc3_sources`, we will then need to check the `type` field of `combined_mc3_sources` to determine whether the node is Beneficial Owner or Company Contacts.

```{r}
# Forming the nodes from the combined_sources
id1 <- combined_mc3_sources %>%
  select(source) %>%
  rename(id = source)

id2 <- combined_mc3_sources %>%
  select(target) %>%
  rename(id = target)

# create a new nodes data table derived from the source and target of edge data. This would ensure that only nodes with connections will be included.
mc3_nodes_combined <- rbind(id1, id2) %>%
  distinct()

# Adding a group attribute, into the nodes dataframe, to differentiate whether the node is a Company, Beneficial Owner or Company Contacts. 
# mc3_nodes_combined <- mc3_nodes_combined %>%
#   mutate( group = case_when(
#     id %in% combined_mc3_sources$source ~ "Company",
#     id %in% combined_mc3_sources$target & combined_mc3_sources$type == "Beneficial Owner" ~ "Beneficial Owner",
#       TRUE ~ "Company Contacts"
#     )
#   )


mc3_nodes_combined <- mc3_nodes_combined %>%
  mutate( group = case_when(
    id %in% combined_mc3_sources$source ~ "Company",
    id %in% bo_above_5$target ~ "Beneficial Owner",
    id %in% cc_above_4$target ~ "Company Contacts"
    )
  )
```


## 3.2. Initial Network Visualisation & Analysis

[**Building the tbl_graph object for visualisation**]{.underline}

We will build up the `tbl_graph` object in preparation to visualise the Company-Individual Relationship.

```{r}
# Build tbl_graph using the valid nodes and edges 
mc3_graph <- tbl_graph(nodes = mc3_nodes_combined,
                       edges = combined_mc3_sources,
                       directed = FALSE)

# Renaming the id column to label and
# create a new column, id with the row_number()
mc3_graph <- mc3_graph %>%
  activate(nodes) %>%
  rename(label = id) %>%
  mutate(id=row_number())

# Converting the nodes with the centrality measures into a tibble dataframe
nodes_df <- mc3_graph %>%
  activate(nodes) %>%
  as_tibble() 

# Converting the edges into a tibble dataframe
edges_df <- mc3_graph %>%
  activate(edges) %>%
  as_tibble()
```

[**Visualisation of the Company-Individual Relationship**]{.underline}

[**Design Consideration**]{.underline}

We will make use of the `group` attribute that we created in the earlier section to clearly identify the different types of nodes (Company, Beneficial Owner, Company Contacts).

For the ease of selecting a particular entity, a dropdown list with all the entities (nodes) present in the graph is provided. The list is also sorted in ascending order by using `arrange()`.

Mouse pointer hover action is also included on the graph so that the user can hover the mouse pointer over the graph to look at the possible different 'groups' of connectivity.

```{r}
# Preparing the data for visualisation
nodes <- nodes_df %>%
  filter(id %in% c(edges_df$from, edges_df$to)) %>%
  arrange(label) 

# Building the network graph using visNetwork package
vis_nw <- visNetwork(nodes, edges_df,
                     main = "An Overview of the Company-Individual Relationship") %>%
  visIgraphLayout(layout = "layout_with_fr") %>%
  visLayout(randomSeed = 1234) %>%
  visNodes(size = 30) %>%
  visOptions(highlightNearest = list(enabled = T, degree = 2, hover = T),
             nodesIdSelection = TRUE) %>%
  visLegend(width = 0.1, position = "right", main = "group") %>%  
  visEdges(smooth = list(enabled = TRUE, type = "curvedCW"))

vis_nw
```

::: {.callout-note title="Observations"}
From the network graph above, we are able to see the relationships of the individual Beneficial Owner/Company Contact to the companies that they have linked. 

We can also see that there is a significantly network which comprised of 7 smaller clusters, as shown in the image below.

![](images/img2_overview_nw_coy_to_individual.png){fig-align="center" width="492"}

The following 2 diagrams are zoomed in, to identify the key nodes in play.

![](images/img3_overview_nw_coy_to_individual02.png){fig-align="center" width="490"}

![](images/img3_overview_nw_coy_to_individual03.png){fig-align="center" width="488"}

For the purpose of analysis, the labels of the connected nodes are listed below:

-   Red-Coloured Node (Company Contacts): `David Smith`
-   Yellow-Coloured Nodes (Beneficial Owners): 

    -   `James Smith`
    -   `Mary Williams`
    -   `David Thomas`
    -   `Jessica Brown`
    -   `Michael Miller` and 
    -   `Jennifer Smith`

-   Connecting Nodes:

    -   `Spanish Shrimp A/S Marine` (between `James Smith` and `David Smith`)
    -   `Ocean Quest S.A. de C.V.` (between `David Smith` and `David Thomas`)
    -   `Nagaland Sea Catch Ltd. Liability Co Logistics` (between `Mary Williams` and `David Thomas`)
    -   `BlueTide GmbH & Co. KG` (betweeen `David Thomas` and `Jessica Brown`)
    -   `West Fish  GmbH Transport` (between `Jessica Brown` and `Michael Miller`)
    -   `Mar del Oeste -` (between `Jessica Brown` and `Jennifer Smith`)
    
We will need to pay special attention to the above-mentioned nodes. 
:::


## 3.3. Merging the information with *mc3_nodes_raw*

Firstly, we will make use of the `setdiff()` function to identify the values that are missing in `mc3_nodes_raw`. `missing_source` will contain all the values that are present in `combined_mc3_sources$source` but not in `mc3_nodes_raw$id`.

We will then create a tibble dataframe, containing this list, in preparation to combine it with `combined_mc3_sources` to form the eventual nodes dataframe for analysis. 

As we do not have any information for `country`, `revenue_omu` and `product_services` fields, we will make use of `NA_character_` and `NA_real_` constants in R to pre-fill the missing values. 

We will also perform the similar steps for `combined_mc3_sources$target`.

```{r}
# Identify missing values in the 'source' column of 'combined_mc3_sources'
missing_source <- setdiff(combined_mc3_sources$source, mc3_nodes_raw$id)

# Create a new dataframe for the missing 'source' values
missing_source_df <- tibble(
  id = missing_source,
  country = rep(NA_character_, length(missing_source)),
  type = rep("Company", length(missing_source)),
  revenue_omu = rep(NA_real_, length(missing_source)),
  product_services = rep(NA_character_, length(missing_source))
)

# Identify missing values in the 'target' column of 'combined_mc3_sources'
missing_target <- setdiff(combined_mc3_sources$target, mc3_nodes_raw$id)

# Create a new dataframe for the missing 'target' values
missing_target_df <- tibble(
  id = missing_target,
  country = rep(NA_character_, length(missing_target)),
  type = combined_mc3_sources$type[match(missing_target,
                                         combined_mc3_sources$target)],
  revenue_omu = rep(NA_real_, length(missing_target)),
  product_services = rep(NA_character_, length(missing_target))
)

# Filter the 'nodes' dataframe to keep only the 'id' values present in 'combined_mc3_sources'
filtered_nodes <- mc3_nodes_raw %>%
  filter(id %in% combined_mc3_sources$source | 
         id %in% combined_mc3_sources$target)

# Combine the missing source and target dataframes with the filtered_nodes dataframe above
nodes_combined <- bind_rows(filtered_nodes, 
                            missing_source_df, 
                            missing_target_df)
```

```{r}
# Renaming the id column to label and
# create a new column, id with the row_number()
nodes_combined <- nodes_combined %>%
  rename(label = id) %>%
  mutate(id=row_number()) 
```


## 3.4 Text Mining with tidytext

Now that we have the full list of nodes, We will use `unnest_token()` of **tidytext** to perform tokenisation and split text in product_services field into words. By default, punctuation has been stripped and the tokens will be converted to lowercase before comparison. Hence, we will stick to the default configurations, which is sufficient for our word comparison.


```{r}
# This is a very basic code of unnest_token()
nodes_combined_unnest <- nodes_combined %>%
  unnest_tokens(word, product_services)
```

We will then visualise the words extracted by selecting the top 30 words. 

```{r}
nodes_combined_unnest %>%
  count(word, sort = TRUE) %>%
  top_n(30) %>%
  mutate(word = reorder(word, n)) %>%
  ggplot(aes(x = word, y = n)) +
  geom_col() +
  xlab(NULL) +
  coord_flip() +
      labs(x = "Count",
      y = "Unique words",
      title = "Count of unique words found in product_services field")
```
:::{.callout-note title="Observations"}
The bar chart reveals that the unique words contains some words that may not be useful to use. For instance "a" and "to". In the word of text mining we call those words stop words. We will remove these words from the analysis as they are fillers used to compose a sentence.

In addition, there is also a high number of the words `NA`, `character`, `0`, `unknown`, `products` which are not representative of the products_services field. Hence, we will add them into the `stop_words` dataset in **tidytext** so that they can be filtered out.
:::

### 3.4.1. Adding stop words into the tidytext `stop_words` dataset

We will first retrieve the list of stop_words dataset. Next, we will create a list `additional_stop_words`, that will contains the additional words that we want to remove. 

We will then use `bind_rows()` to add the `additional_stop_words` into the `stop_words` dataset. We will call `distinct()` function to make sure that there is no duplicate stop_words in the dataset.

```{r}
# Retrieve the current stop_words dataset
data(stop_words)

# Create a vector containing the additional stop words
additional_stop_words <- c(NA_character_, "character", "0", 
                           "unknown", "products")

# Add the additional stop words to the stop_words dataset and remove any duplicate entries
stop_words <- bind_rows(stop_words, 
                        tibble(word = additional_stop_words))

stop_words <- distinct(stop_words)
```

**NOTE: - there are also `NA` for revenue_omu field - Beneficial Owner will be linked to Company; Company Contacts will be linked to Company. Technically, there should not be any linkages between Beneficial Owner and Company Contacts.**

### 3.4.2. Removing the Stop Words

```{r}
nodes_combined_no_stopwords <- nodes_combined_unnest %>%
  anti_join(stop_words)
```

We can then visualise the words after removing the stop words.

```{r}
nodes_combined_no_stopwords %>%
  count(word, sort = TRUE) %>%
  top_n(30) %>%
  mutate(word = reorder(word, n)) %>%
  ggplot(aes(x = word, y = n)) +
  geom_col() +
  xlab(NULL) +
  coord_flip() +
      labs(x = "Count",
      y = "Unique words",
      title = "Count of unique words found in product_services field")
```

### 3.4.3. Retrieving the nodes that contain fishing-related keywords

In order to find the companies that are related to fishing, we will extract all the nodes that contain fishing-related keywords.

```{r}
# build the nodes table
nodes_with_fishing <- nodes_combined_no_stopwords %>%
  filter(word %in% c("fish", "fishing", "seafood", "seafoods", "salmon",
                     "shrimp", "prawn", "crabs", "squid", "oysters",
                     "clams", "trout", "cod", "lobster", "catfish", 
                     "mackerel", "herring", "pollock", "tuna", 
                     "trout", "finfish", "fresh")) %>%
  select(id, label, country, type, revenue_omu, word) %>%
  group_by(id, label, country, type, revenue_omu, word) %>%
  arrange(label) %>%
  ungroup()


# Combine the words for the same id using aggregate(), so that we will end up with 1 record per node
combined_words_nodes_fishing <- nodes_with_fishing %>%
  group_by(id) %>%
  summarize(product_services = paste(unique(word), collapse = ","),
            label = unique(label), country = unique(country), 
            type = unique(type), revenue_omu = unique(revenue_omu),
            .groups = "drop") %>%
  select(label, country, type, revenue_omu, product_services) %>%
  rename(id = label)

# build the edges table based on the nodes in nodes_combined_fishing
edges_fishing <- combined_mc3_sources %>%
  filter(source %in% combined_words_nodes_fishing$id |
         target %in% combined_words_nodes_fishing$id)  

```



```{r}
#nodes_combined_fishing <- nodes_combined_fishing %>%
combined_words_nodes_fishing <- combined_words_nodes_fishing %>%
  rename(label = id) %>%
  mutate(id=row_number())

edges_fishing <- edges_fishing %>%
  rename(from = source) %>%
  rename(to = target)
```


# 4. Data Exploration & Visualisation

## 4.1. Visualising Fishing-Related Companies and their Beneficial Owners and Company Contacts

For this section, we will visualise the relationship of fishing-related companies with their beneficial owners and company contacts. 

```{r}
id1_fish <- edges_fishing %>%
  select(from) %>%
  rename(id = from)

id2_fish <- edges_fishing %>%
  select(to) %>%
  rename(id = to)

# create a new nodes data table derived from the source and target of edge data. This would ensure that only nodes with connections will be included.
fish_nodes_combined <- rbind(id1_fish, id2_fish) %>%
  distinct()

fish_nodes_combined <- fish_nodes_combined %>%
  mutate( group = case_when(
    id %in% edges_fishing$from ~ "Company",
    id %in% edges_fishing$to & 
      edges_fishing$type == "Beneficial Owner" ~ "Beneficial Owner",
    id %in% edges_fishing$to & 
      edges_fishing$type == "Company Contacts" ~ "Company Contacts"
    )
  )
```


```{r}
visNetwork(fish_nodes_combined,
           edges_fishing,
           main = "Network Graph of Fishing-Related Entities") %>%
  visIgraphLayout(layout = "layout_with_fr") %>%
  visLayout(randomSeed = 1234) %>%
  visOptions(highlightNearest = list(enabled = T, degree = 2, hover = T),
             nodesIdSelection = TRUE) %>%
  visNodes(id = fish_nodes_combined$label, size=50) %>%
  visLegend(width = 0.1, position = "right", main = "Group") %>%
  visEdges(smooth = list(enabled = TRUE, type = "curvedCW"))
```


## 4.2. Understanding the Fishing-related Companies - Country

For this section, we will find out more about the fishing-related companies, particularly on the country that they belong.

```{r}
#| fig-width: 10
# Computing the count of companies by country
combined_words_nodes_fishing_ctry <- combined_words_nodes_fishing %>%
  group_by(country) %>%
  summarize(ctry_cnt = n())

ggplot_tm <- ggplot(combined_words_nodes_fishing_ctry, 
       aes(area = ctry_cnt, label = country, fill = country)) +
  geom_treemap() +
  geom_treemap_text(aes(label = paste(country, "\nCount:", ctry_cnt)),
                    size = 10, hjust = 0.5, vjust = 0.5) +
  labs(title = "Countries of the fishing-related Companies") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5))

ggplot_tm
```




```{r}
#| eval: false
### Exporting to CSV for closer examination
# write_csv(x = tidy_nodes_no_stopwords,
#           "data/generated/tidy_nodes_no_stopwords.csv")
# write_csv(x = mc3_nodes, "data/generated/mc3_nodes.csv")
#  write_csv(x = mc3_edges, "data/generated/mc3_edges.csv")
# 
# write_rds(mc3_nodes, "data/generated/mc3_nodes.rds")
# write_rds(mc3_edges, "data/generated/mc3_edges.rds")
# 
# read_mc3_nodes <- read_rds("data/generated/mc3_nodes.rds")
# read_mc3_edges <- read_rds("data/generated/mc3_edges.rds")
```
