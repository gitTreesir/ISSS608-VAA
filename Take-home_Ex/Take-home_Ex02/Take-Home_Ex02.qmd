---
title: "Take-Home Exercise 02"
author: "Ong Chae Hui"
date: 17 May 2023
date-modified: "`r Sys.Date()`"
execute:
  echo: true
  eval: true
  warning: false
  freeze: auto  
format: 
  html:
    code-fold: false
    code-summary: "Show the codes"
    code-overflow: wrap
    code-block-bg: true
engine: knitr
---

# 1. Overview

With reference to the [Mini-Challenge 2](#0) of [VAST Challenge 2023](#0) and by using appropriate **static and interactive statistical graphics** methods, we will help FishEye identify companies that may be engaged in illegal fishing.

## 1.1. The Task

Use visual analytics to identify temporal patterns for individual entities and between entities in the knowledge graph FishEye created from trade records. Categorize the types of business relationship patterns you find.

## 1.2. Data Source

For this task, we will make use of the *mc2_challenge_graph.json* provided for the data analysis and visualisation.

# 2. Loading and Launching of Required R Packages

The required R library packages are being loaded. For this exercise, we will make use of the following R library packages.

-   **jsonlite**, JSON parser and generator optimized for statistical data and the web.
-   **tidygraph** provides a tidy framework for all things relational (networks/graphs, trees, etc.)
-   **ggraph**, an extension of the ggplot2 API tailored to graph visualizations and provides the same flexible approach to building up plots layer by layer.
-   **visNetwork** for network visualization.
-   **lubridate** is an R package that makes it easier to work with dates and times.
-   **igraph** a library collection for creating and manipulating graphs and analyzing networks.
-   **tidyverse**, a family of modern R packages specially designed to support data science, analysis and communication task including creating static statistical graphs.
-   **DT** provides an R interface to the JavaScript library DataTables that create interactive table on html page.

The code chunk below uses `pacman::p_load()` to check if the above packages are installed. If they are, they will be loaded into the R environment.

```{r}
pacman::p_load(jsonlite, tidygraph, ggraph, visNetwork, lubridate,
               igraph, tidyverse, DT)
```

# 3. Data Preparation

We will first load each of the data files into the environment and perform data wrangling.

## 3.1. Loading and Extracting the Data

Based on the VAST 2023 data notes, column `dataset` will always be 'mc2', to represent this set of data belongs to mini challenge 2. As such, we will not import this column into the R environment.

### 3.1.1. Load main file *mc2_challenge_graph.json*

We will first load in the main file, *mc2_challenge_graph.json*, then extract the nodes and edges (links) information out.

```{r}
mc2 <- fromJSON("data/mc2_challenge_graph.json")
```

#### 3.1.1.1. Extracting the nodes data.frame from mc2

```{r}
mc2_nodes <- as_tibble(mc2$nodes) %>%
  select(id, shpcountry, rcvcountry)
```

#### 3.1.1.2. Extracting the edges (links) data.frame from mc2

```{r}
mc2_edges <- as_tibble(mc2$links) %>%
  select(source, target, arrivaldate, hscode,
         weightkg, valueofgoods_omu, volumeteu,
         valueofgoodsusd)
```

#### 3.1.1.3. Examining the structure of *mc2_nodes* and *mc2_edges* data.frames using `glimpse()` of **dyplr**.

```{r}
glimpse(mc2_nodes)
glimpse(mc2_edges)
```

::: {.callout-tip title="Examination of the data structure"}
1.  There are a number of `chr` data type columns in both *mc2_nodes* and *mc2_edges*, as a good practice, we will trim away any possible leading and trailing white spaces of the data, before we perform any analysis.

2.  The *arrivaldate* has the format of 'YYYY-MM-DD' and is treated as `chr` data type instead of `date` data type.

3.  A closer examination on the columns `valueofgoods_omu`, `volumeteu`, `valueofgoodsusd` columns revealed that there are also a large number of `NA` (missing values) and are deemed as as incomplete. We will drop these columns from analysis.

4.  We will also need to filter out any possible duplicate records by using the `distinct()` function.
:::

#### 3.1.1.4. Perform Data Wrangling for *mc2_edges*

::: {.callout-tip title="Data Preparation for mc2_edges"}
1.  Drop columns `valueofgoods_omu`, `volumeteu` and `valueofgoodsusd` since they are deemed as as incomplete for analysis.

2.  Convert *arrivaldate* from `chr` data type to `date` data type by using `ymd()`.

3.  Extract the *year* component out from *arrivaldate* field with `year()`.

4.  Perform white space trimming for the `chr` columns,to remove any the leading and trailing white spaces with `trimws()`.

5.  Remove any possible duplicate records by using `distinct()`

6.  Based on the data notes provided in the VAST Challenge, `hscode` refers to the Harmonized Commodity Description and Coding System Nomenclature (HS) developed by World Customs Organization (WCO). We will filter all the records based on the hscodes related to the context of the challenge. The relevant hscodes are prefixed with: `301`, `302`, `303`, `304`, `305`, `306`, `307`, `308`, `309`, `1504`, `1603`, `1604`, `1605` and `2301`).

7.  Aggregate the records, by deriving a `weight` column based on the number of records by grouping the `source`, `target`, `hscode` and `year`.
:::

```{r}
# For the edges data frame, we will make use of select() to extract 
# and rearrange the columns.
mc2_edges <- mc2_edges %>%
  select(arrivaldate, source, target, hscode, weightkg) %>%
  mutate(arrivaldate = ymd(arrivaldate)) %>%
  mutate(year = year(arrivaldate)) %>%
  mutate(source = trimws(source)) %>%
  mutate(target = trimws(target)) %>%
  mutate(hscode = trimws(hscode)) %>%
  distinct()
```

```{r}
# List of relevant hscodes related to fishing
rel_hscodes_3 <- c("301", "302", "303", "304", "305",
                   "306", "307", "308", "309")

rel_hscodes_4 <- c("1504", "1603", "1604", "1605", "2301")

# Extract the records with the above 1st 3 or 4 characters of hscodes
# using substr().
mc2_edges_aggregated <- mc2_edges %>%
  filter((substr(hscode, 1, 3) %in% rel_hscodes_3) |
         (substr(hscode, 1, 4) %in% rel_hscodes_4)) %>%
  group_by(source, target, hscode, year) %>%
  summarise(weight = n()) %>%
  filter(source!=target) %>%
  arrange(weight) %>%
  ungroup()
```

#### 3.1.1.5. Perform Data Wrangling for *mc2_nodes*

::: {.callout-tip title="Data Preparation for mc2_nodes"}
The nodes within the node file must be unique and since we have filtered and cleaned the data in *mc2_edges_aggregated*, we will make use of this to extract the nodes that are used here.

`rbind()` is used to combine the data in both `source` and `target` columns of *mc2_edges_aggregated*. We will then extract the unique records to form the nodes data frame.
:::

```{r}
id1 <- mc2_edges_aggregated %>%
  select(source) %>%
  rename(id = source)
id2 <- mc2_edges_aggregated %>%
  select(target) %>%
  rename(id = target)

# create a new nodes data table derived from the source and target of edge data. This would ensure that only nodes with connections will be included.

mc2_nodes_extracted <- rbind(id1, id2) %>%
  distinct()
```

```{r}
# Build tbl_graph using the valid nodes and edges 
mc2_graph <- tbl_graph(nodes = mc2_nodes_extracted,
                       edges = mc2_edges_aggregated,
                       directed = TRUE)
```


# 4. Data Exploration

As part of the data exploration and analysis, we will compute the centrality indices for the nodes and include them as attribute information to the nodes, before plotting them out for visualisation and analysis. We will also rename the `id` column to `label` and create a new column `id` by using the `row_number()`.

```{r}
mc2_graph <- mc2_graph %>%
  activate(nodes) %>%
  rename(label = id) %>%
  mutate(id=row_number()) %>%  
  
  # Compute the betweenness centrality and bin the scores into logical groups
  mutate(betweenness_score = centrality_betweenness()) %>%
  mutate(bet_bin = cut(betweenness_score, 
                       breaks = c(0, 50000, 100000, 500000, Inf),
                       labels = c("Low\n(0-49K)", 
                                  "Medium\n(50K-99K)", 
                                  "High\n(100K-499K)\n",
                                  "Very High\n(>=500K)"),
                       include.lowest = TRUE)) %>%  
  
  # Compute the closeness centrality and bin the scores into logical groups
  mutate(closeness_score = centrality_closeness()) %>%
  mutate(close_bin = cut(closeness_score,
                         breaks = c(0, 0.5, 0.8, Inf),
                         labels = c("Low\n(<=0.49)", 
                                    "Medium\n(0.5-0.79)", 
                                    "High\n(>=0.8)\n"), 
                         include.lowest = TRUE)) %>%

  # Compute the degree centrality of each node and bin the scores into logical groups
  mutate(degree_score = centrality_degree()) %>%
  mutate(deg_bin = cut(degree_score, breaks = c(0, 200, 300, Inf),
                       labels = c("Low\n(0-199)", 
                                  "Medium\n(200-299)", 
                                  "High\n(>=300)\n"),  
                       include.lowest = TRUE))  %>%

  # Compute the centrality score and bin the scores into logical groups
  mutate(centrality = centrality_authority()) %>%
  mutate(cent_bin = cut(centrality, breaks = c(0, 0.5, 0.8, Inf),
                       labels = c("Low\n(0-0.49)", 
                                  "Medium\n(0.5-0.79)", 
                                  "High\n(>=0.8)\n"),  
                       include.lowest = TRUE))
  

# Computing the in-degree and out-degree centralities
# Convert to igraph for computing the in-degree and out-degree centrality
igraph_obj <- as.igraph(mc2_graph)

# In-degree centrality
in_degree_centrality <- degree(igraph_obj, mode = "in")

# Out-degree centrality
out_degree_centrality <- degree(igraph_obj, mode = "out")

# Assigning in-degree and out-degree centrality as vertex attributes
V(mc2_graph)$in_degree <- in_degree_centrality
V(mc2_graph)$out_degree <- out_degree_centrality

# Binning the in_degree scores and put as a variable inside mc2_graph
mc2_graph <- mc2_graph %>% 
  mutate(in_bin = cut(in_degree, 
                      breaks = c(0, 300, 600, Inf),
                      labels = c("Low\n(<300)", "Medium\n(300-599)", 
                                 "High\n(>=600)"),
                      include.lowest = TRUE)) %>%
  
  mutate(out_bin = cut(out_degree, 
                       breaks = c(0, 2, 300, 500, Inf),
                       labels = c("0-1", "Low\n(2-300)", 
                                  "Medium\n(301-500)", "High\n(>500)"),
                       include.lowest = TRUE))
```

```{r}
# Converting the nodes with the centrality measures into a tibble dataframe
nodes_df <- mc2_graph %>%
  activate(nodes) %>%
  as_tibble() 
```


```{r}
# Converting the edges into a tibble dataframe
edges_df <- mc2_graph %>%
  activate(edges) %>%
  as_tibble()
```


## 4.1.Overview of the Network

From the network graph below, each node represents an individual business entity (`label`), which you could select from the dropdown list, to examine the connectivity of this entity with other entities.

In order to prevent the network graph from overcluttering, all edges with weight \<= 50 will not be displayed.

For the ease of selecting a particular entity, the dropdown list has been sorted in ascending order by using `arrange()`.

In addition, directional arrows have also been included on the edges, to help identify the nodes that are highly connected to other nodes in the network.

Hover action is also enabled for the graph so that the user can hover the mouse pointer over the graph to look at the possible different 'groups' of connectivity.

```{r}
# Preparing the data for visualisation
edges <- edges_df %>%
  filter(weight > 50)

nodes <- nodes_df %>%
  filter(id %in% c(edges$from, edges$to)) %>%
  arrange(label)

vis_nw <- visNetwork(nodes, edges,
                     main = "An Overview of the Network Graph") %>%
  visIgraphLayout(layout = "layout_with_fr") %>%
  visLayout(randomSeed = 1234) %>%
  visNodes() %>%
  visOptions(highlightNearest = list(enabled = T, degree = 2, hover = T),
             nodesIdSelection = TRUE) %>%
  visEdges(arrows = "to", smooth = list(enabled = TRUE, type = "curvedCW"))

vis_nw
```


::: {.callout-note title="Observations"}
From the above network graph, we noticed that some of the nodes in the middle cluster seemed to be denser compared to the rest, indicating that these nodes probably have more connections to the other nodes. With the help of the hover function, we were able to identify the ids of these nodes. However, it requires the user to maneuver around the graph with great efforts.

We will make use of the different centrality indices (Centrality, Betweenness Centrality, Closeness Centrality, Degree Centrality, In-Degree and Out-Degree Centrality) to aid in identifying the key nodes of the network in the subsequent sections.
:::


## 4.2. The High Centrality Index Nodes

We will attempt to identify the nodes with high centrality index, that would most likely be the main hubs within the network.

Firstly, we will take a look at the distribution of the centrality index across all the nodes to gain an overview picture of the network. 

In view that there are some extrememly low count figure, the `count` for each bin is displayed at the top of each bar for ease of reference.

::: panel-tabset

### Distribution of Centrality Index 
```{r}
#| echo: false

# Plotting the Distribution for Centrality 

# Get the count of the records in each bin
nodes_df_cent_gp <- nodes_df %>%
  group_by(cent_bin) %>%
  summarise(cnt = n())

# Create a distribution with bar chart using ggplot2
plot_cent <- ggplot(nodes_df_cent_gp, aes(x = cent_bin, y = cnt)) +
  geom_bar(stat = "identity", fill = "deepskyblue3") +
  geom_text(aes(label = cnt), vjust = -0.5, color = "black") +
  labs(x = "\nCentrality Index", y = "Count\n", 
       title = "Distribution of Centrality Index of the Nodes") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5)) 

plot_cent
```

### Code Chunk
```{r}
#| eval: false
#| code-fold: false

# Plotting the Distribution for Centrality 

# Get the count of the records in each bin
nodes_df_cent_gp <- nodes_df %>%
  group_by(cent_bin) %>%
  summarise(cnt = n())

# Create a distribution with bar chart using ggplot2
plot_cent <- ggplot(nodes_df_cent_gp, aes(x = cent_bin, y = cnt)) +
  geom_bar(stat = "identity", fill = "deepskyblue3") +
  geom_text(aes(label = cnt), vjust = -0.5, color = "black") +
  labs(x = "\nCentrality Index", y = "Count\n", 
       title = "Distribution of Centrality Index of the Nodes") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5)) 

plot_cent
```
:::

::: {.callout-note title="Observations from the Distribution of Centrality Index"}
The graph above revealed that there are **3** nodes that have a centrality index \> 0.5. This means that these nodes are well-connected to other nodes in the network. These nodes have very high number of in-degree centrality index, indicating that they are most likely to be the fishery wharves/central collection centers.

With that information, we will study these 3 entities in greater details.
:::

```{r}
# Extracting the top 3 entities with highest centrality indices
nodes_df_cent_top3 <- nodes_df %>%
  filter(centrality >= 0.5) %>%
  select(id, label, centrality, cent_bin, deg_bin, 
         in_bin, out_bin, bet_bin, close_bin) %>%
  arrange(desc(centrality))

top_3_cent <- head(nodes_df_cent_top3, 3)

datatable(head(top_3_cent, 3), 
          colnames = c("ID", "Entity", "Centrality Index", "Centrality Category",
                       "Degree Centrality Category", "In-Degree Centrality Category",
                       "Out-Degree Centrality Cateogy", "Betweenness Index Category",
                       "Closeness Index Category"),
          options = list(
            columnDefs = list(list(className = 'dt-center', targets = 1:5),
                    list(targets = 5, visible = FALSE))))

```

```{r}
# get the company names for the edges
edges_df_cent <- edges_df %>%
  filter(from %in% top_3_cent$id |
         to %in% top_3_cent$id) %>%
  filter(weight > 10)

# build the nodes table
nodes_cent <- nodes_df %>%
  filter(id %in% c(edges_df_cent$from, edges_df_cent$to)) %>%
  rename(group = cent_bin)

visNetwork(nodes_cent,
           edges_df_cent,
           main = "Network Graph of the Top 3 Entities with High Centrality") %>%
  visIgraphLayout(layout = "layout_with_fr") %>%
  visLayout(randomSeed = 1234) %>%
  visOptions(highlightNearest = list(enabled = T, degree = 2, hover = T),
             nodesIdSelection = TRUE) %>%
  visNodes(id = nodes_cent$id, size=10) %>%
 visLegend() %>%  
  visEdges(arrows = "to", 
           smooth = list(enabled = TRUE, 
                         type = "curvedCW"))
```

::: {.callout-note title="Observations"}
Based on the DataTable and network graph, these 3 entities are likely to be the primary fishery wharves/collection centers within the network, as they have high in-degree centrality indices. However,the low out-degree centrality index, betweenness centrality index and closeness centrality index suggested that these nodes have limited impact/reach within the network.
:::


## 4.3. Looking at the Degree of Centrality

Degree centrality is a measure of the importance or popularity of a node in a network based on the number of connections it has. It quantifies how many direct connections a node has with other nodes in the network.

Nodes with high degree centrality have many connections or interactions with other nodes. They are often considered as influential or popular within the network since they have a wide reach and can easily communicate or spread information to other nodes. On the other hand, nodes with low degree centrality have fewer connections and may have limited influence or reach within the network.

In simpler terms, degree centrality captures how well-connected or popular a node is in a network. It reflects the number of direct connections a node has and provides insights into its potential influence, access to information, or ability to transmit messages to other nodes.

```{r}
# Plotting the Distribution for Degree Centrality
nodes_df_deg_gp <- nodes_df %>%
  group_by(deg_bin) %>%
  summarise(cnt = n())

# Create a bar chart with hover text using ggplot2
plot <- ggplot(nodes_df_deg_gp, aes(x = deg_bin, y = cnt)) +
  geom_bar(stat = "identity", fill = "deepskyblue3") +
  geom_text(aes(label = cnt), vjust = -0.5, color = "black") +
  labs(x = "\nDegree Centrality", y = "Count\n", 
       title = "Distribution of Degree Centrality of the Nodes") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5)) 

plot
```

```{r}
# Extract the nodes with high degree centrality index

nodes_df_deg <- nodes_df %>%
  filter(degree_score >= 300) %>%
  select(id, label, degree_score, deg_bin, closeness_score, close_bin, 
         betweenness_score, bet_bin, centrality, 
         in_degree, in_bin, out_degree, out_bin) %>%  
  arrange(desc(degree_score))

datatable(nodes_df_deg, class= "compact")
```

```{r}
# get the company names for the edges
edges_df_deg <- edges_df %>%
  filter(from %in% nodes_df_deg$id |
         to %in% nodes_df_deg$id) %>%
  filter(weight > 10)

# build the nodes table
nodes_deg <- nodes_df %>%
  filter(id %in% c(edges_df_deg$from, edges_df_deg$to)) %>%
  rename(group = deg_bin)

visNetwork(nodes_deg,
           edges_df_deg,
           main = "Entities with High Degree Centrality Index") %>%
  visIgraphLayout(layout = "layout_with_fr") %>%
  visLayout(randomSeed = 1234) %>%
  visOptions(highlightNearest = list(enabled = T, degree = 2, hover = T),
             nodesIdSelection = TRUE) %>%
  visNodes(id = nodes_deg$id, size=10) %>%
  visLegend() %>%  
  visEdges(arrows = "to", 
           smooth = list(enabled = TRUE, 
                         type = "curvedCW"))
```
::: {.callout-note title="Observations"}
**???TBA??? **
:::


## 4.4. Looking at the In-Degree Centrality

In-degree centrality is a measure of centrality in a network that focuses on incoming connections to a node. In simple terms, it quantifies how popular or influential a node is based on the number of incoming connections it receives from other nodes in the network.

Nodes with high in-degree centrality are often considered influential or important within the network. They have a larger number of connections pointing towards them, indicating that they receive a lot of attention, information, or resources from other nodes. In social networks, individuals with high in-degree centrality may be seen as popular or well-connected, as they have a large number of friends.

In-degree centrality is particularly useful when studying networks where the focus is on nodes receiving information, resources, or influence from others. It helps identify key individuals or nodes that are central to the flow of information or interactions within the network.

::: panel-tabset

### Distribution for In-Degree Centrality
```{r}
#| echo: false

# Plotting the Distribution for In-Degree centrality 
nodes_df_in <- nodes_df %>%
  group_by(in_bin) %>%
  summarise(cnt = n())

# Create a bar chart with hover text using ggplot2
plot_in <- ggplot(nodes_df_in, aes(x = in_bin, y = cnt)) +
  geom_bar(stat = "identity", fill = "deepskyblue3") +
  geom_text(aes(label = cnt), vjust = -0.5, color = "black") +
  labs(x = "\nIn-Degree Centrality", y = "Count\n", 
       title = "Distribution of In-Degree Centrality of the Nodes") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5)) 

plot_in
```

### Code Chunk
```{r}
#| eval: false
#| code-fold: false

# Plotting the Distribution for In-Degree centrality 
nodes_df_in <- nodes_df %>%
  group_by(in_bin) %>%
  summarise(cnt = n())

# Create a bar chart with hover text using ggplot2
plot_in <- ggplot(nodes_df_in, aes(x = in_bin, y = cnt)) +
  geom_bar(stat = "identity", fill = "deepskyblue3") +
  geom_text(aes(label = cnt), vjust = -0.5, color = "black") +
  labs(x = "\nIn-Degree Centrality", y = "Count\n", 
       title = "Distribution of In-Degree Centrality of the Nodes") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5)) 

plot_in
```
:::

::: {.callout-note title="Observations from the Distribution of In-Degree Centrality Index"}
Majority of the entities in the network have low number of in-degree centrality index, which suggest that they are likely to be the fishing vessels within the network. 

It is observed that there are **27** nodes with significantly high in-degree centrality index (\>=600), which we will study them in more details.
:::


```{r}
# Extracting the top companies with highest in-degree centrality
nodes_df_in_top <- nodes_df %>%
  filter(in_degree >= 600) %>%
  select(id, label, in_degree, in_bin, cent_bin, 
         deg_bin, close_bin, bet_bin, out_bin) %>%
  arrange(desc(in_degree))

top_in <- head(nodes_df_in_top, 27)

datatable(top_in, 
          colnames = c("ID", "Entity", "In-Degree Centrality Index",
                       "In-Degree Centrality Category", "Centrality Category",
                       "Degree Centrality Category", "Closeness Index Category",
                       "Betweenness Centrality Category", 
                       "Out-Degree Centrality Cateogy"),
          options = list(
            columnDefs = list(list(className = 'dt-center', targets = 1:5),
                    list(targets = 5, visible = FALSE))))

```

```{r}
# get the company names for the edges
edges_df_in <- edges_df %>%
  filter(from %in% top_in$id |
         to %in% top_in$id) %>%
  filter(weight > 50)

# build the nodes table
nodes_in <- nodes_df %>%
  filter(id %in% c(edges_df_in$from, edges_df_in$to)) %>%
  rename(group = in_bin)

visNetwork(nodes_in,
           edges_df_in,
           main = "Entities with High In-Degree Centrality Index") %>%
  visIgraphLayout(layout = "layout_with_fr") %>%
  visLayout(randomSeed = 1234) %>%
  visOptions(highlightNearest = list(enabled = T, degree = 2, hover = T),
             nodesIdSelection = TRUE) %>%
  visNodes(id = nodes_in$id, size=10) %>%
  visLegend() %>%  
  visEdges(arrows = "to", 
           smooth = list(enabled = TRUE, 
                         type = "curvedCW"))
```
::: {.callout-note title="Observations"}
**???TBA??? **
:::

### 4.4.1 Visualising Community

```{r}
# get the company names for the edges
# edges_df_in_comm <- edges_df %>%
#   filter(from %in% top_in$id |
#          to %in% top_in$id) %>%
#   filter(weight > 100) %>%
#   distinct()

# build the nodes table
# nodes_in_comm <- nodes_df %>%
#   filter(id %in% c(edges_df_in_comm$from, edges_df_in_comm$to)) 
#%>%  rename(group = in_bin)

# Create an igraph object
# igraph_in_comm <- graph_from_data_frame(d=edges_df_in_comm,
#                                         vertices=nodes_in_comm,
#                                         directed = TRUE)

# Apply Infomap community detection algorithm
# clusters <- cluster_infomap(igraph_in_comm)

# Get the cluster membership of each node
# node_clusters <- membership(clusters)

# Assign colors to clusters
# cluster_colors <- rainbow(max(membership(clusters)))


# Add the cluster membership as a column in the nodes data frame
# nodes_df_in_final$cluster <- paste("Cluster", node_clusters)
# nodes_in_comm$group <- membership(group)
# 
# 
# visNetwork(nodes_in_comm,
#            edges_df_in_comm,
#            main = "Network Graph of the top 20 entities with high in-degree") %>%
#   visIgraphLayout(layout = "layout_with_kk") %>%
#   visLayout(randomSeed = 1234) %>%
#   visOptions(highlightNearest = list(enabled = T, degree = 2, hover = T),
#              nodesIdSelection = TRUE) %>%
#   visNodes(id = nodes_df_in_final$id) %>%
#   visEdges(arrows = "to",
#            smooth = list(enabled = TRUE,
#                          type = "curvedCW"))

```

## 4.5. Looking at the Out-Degree Centrality

Out-degree centrality is a measure of centrality in a network that focuses on outgoing connections from a node. In simple terms, it quantifies how much influence or impact a node has on other nodes in the network based on the number of outgoing connections it has.

Nodes with high out-degree centrality are often seen as influential or important within the network. They have a larger number of connections pointing away from them, indicating that they have a greater reach and influence over other nodes. In social networks, individuals with high out-degree centrality may be considered as opinion leaders or trendsetters, as they have a significant impact on the behavior and choices of others.

Out-degree centrality is particularly useful when studying networks where the focus is on nodes influencing or affecting other nodes. It helps identify key individuals or nodes that have a strong impact on the network as they possess many connections that reach other nodes.

::: panel-tabset

### Distribution for Out-Degree Centrality
```{r}
#| echo: false

# Plotting the Distribution for Out-Degree centrality 
nodes_df_out <- nodes_df %>%
  group_by(out_bin) %>%
  summarise(cnt = n())

# Create a bar chart with hover text using ggplot2
plot_in <- ggplot(nodes_df_out, aes(x = out_bin, y = cnt)) +
  geom_bar(stat = "identity", fill = "deepskyblue3") +
  geom_text(aes(label = cnt), vjust = -0.5, color = "black") +
  labs(x = "\nOut-Degree Centrality", y = "Count\n", 
       title = "Distribution of Out-Degree Centrality of the Nodes") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5)) 

plot_in
```

### Code Chunk
```{r}
#| eval: false
#| code-fold: false

# Plotting the Distribution for Out-Degree centrality 
nodes_df_out <- nodes_df %>%
  group_by(out_bin) %>%
  summarise(cnt = n())

# Create a bar chart with hover text using ggplot2
plot_in <- ggplot(nodes_df_out, aes(x = out_bin, y = cnt)) +
  geom_bar(stat = "identity", fill = "deepskyblue3") +
  geom_text(aes(label = cnt), vjust = -0.5, color = "black") +
  labs(x = "\nOut-Degree Centrality", y = "Count\n", 
       title = "Distribution of Out-Degree Centrality of the Nodes") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5)) 

plot_in
```
:::

::: {.callout-note title="Observations from the Distribution of Out-Degree Centrality Index"}
Majority of the entities in the network have low number of out-degree centrality index, which suggest that they are likely to be the fishing vessels within the network, contributing to one of the major fishery wharves/collection centres. 

It is observed that there are **18** nodes with significantly high out-degree centrality index (\>300), which we will study them in more details.
:::


```{r}
# Extracting the top companies with highest out-degree centrality
nodes_df_out <- nodes_df %>%
  filter(out_degree > 300) %>%
  select(id, label, out_degree, out_bin, cent_bin, 
         in_bin, deg_bin, closeness_score, betweenness_score) %>%
  arrange(desc(out_degree))

top_out <- head(nodes_df_out, 18)

datatable(top_out, 
          colnames = c("ID", "Entity", "Out-Degree Centrality Index",
                       "Out-Degree Centrality Category", "Centrality Category",
                       "In-Degree Centrality Cateogy", "Degree Centrality Category",
                       "Closeness Index Category", "Betweenness Centrality Category"),
          options = list(
            columnDefs = list(list(className = 'dt-center', targets = 1:5),
                    list(targets = 5, visible = FALSE))))

```

```{r}
# get the company names for the edges
edges_df_out <- edges_df %>%
  filter(from %in% nodes_df_out$id |
         to %in% nodes_df_out$id) %>%
  filter(weight > 20)

# build the nodes table
nodes_out <- nodes_df %>%
  filter(id %in% c(edges_df_out$from, edges_df_out$to)) %>%
  rename(group = out_bin)

visNetwork(nodes_out,
           edges_df_out,
           main = "Entities with High Out-Degree Centrality Index") %>%
  visIgraphLayout(layout = "layout_with_fr") %>%
  visLayout(randomSeed = 1234) %>%
  visOptions(highlightNearest = list(enabled = T, degree = 2, hover = T),
             nodesIdSelection = TRUE) %>%
  visNodes(id = nodes_out$id, size=10) %>%
  visLegend() %>%  
  visEdges(arrows = "to", 
           smooth = list(enabled = TRUE, 
                         type = "curvedCW"))
```

::: {.callout-note title="Observations"}
**???TBA??? **
:::




## 4.6. Eigenvector Centrality

Eigenvector centrality is a measure to indicate the importance or influence of a node to the other nodes. It considers both the number of connections a node has and the importance of those connections. Nodes with high eigen centrality are not only connected to many other nodes but are also connected to nodes that have high eigen centrality.

### 4.6.1. Data Preparation
```{r}
mc2_edges_aggregated_eigen <- mc2_edges_aggregated %>%
  filter(weight >80) %>%
  ungroup()

id1_eigen <- mc2_edges_aggregated_eigen %>%
  select(source) %>%
  rename(id = source)
id2_eigen <- mc2_edges_aggregated_eigen %>%
  select(target) %>%
  rename(id = target)

# create a new nodes data table derived from the source and target of edge data. This would ensure that only nodes with connections will be included.

mc2_nodes_extracted_eigen <- rbind(id1_eigen, id2_eigen) %>%
  distinct()

mc2_graph_eigen <- tbl_graph(nodes = mc2_nodes_extracted_eigen,
                       edges = mc2_edges_aggregated_eigen,
                       directed = TRUE)

```

### 4.6.2. Plotting the Eigenvector Network Graph
```{r}
quantile_graph <- quantile(eigen_centrality(mc2_graph_eigen)$vector,
                           probs = seq(0, 1, 1/10))

V(mc2_graph_eigen)$size = eigen_centrality(mc2_graph_eigen)$vector

mc2_graph_aggregated_eigen <- delete_vertices(mc2_graph_eigen,
                                        V(mc2_graph_eigen)[size <                                                        quantile_graph[10]])

set.seed (1234)

layout1 <- layout_with_kk(mc2_graph_aggregated_eigen)

#identify top 10% of the new vertices
quantile_graph_aggregated <- quantile(V(mc2_graph_aggregated_eigen)$size,
                                      probs = seq(0, 1, 1/10))

# color yellow if vertices is top 10%
V(mc2_graph_aggregated_eigen)$color <- ifelse (V(mc2_graph_aggregated_eigen)$size >
                                           quantile_graph_aggregated[10],
                                         "darkgoldenrod3", "azure3")

# Greying out the edges so that the yellow nodes will stand out in the graph
E(mc2_graph_aggregated_eigen)$color <- "grey"

#Increase the size of nodes based on their centrality score, only those with high score will be visible
V(mc2_graph_aggregated_eigen)$size <- V(mc2_graph_aggregated_eigen)$size/0.065

plot(mc2_graph_aggregated_eigen, edge.arrow.size=0.25,edge.arrow.mode = "-",
     main = "Most Important/Influential Business Entities in the Network",
     width=30, height=12)
```

```{r}
  vertex_attr(mc2_graph_aggregated_eigen,
              index = V(mc2_graph_aggregated_eigen)$size*0.065 >
                quantile_graph_aggregated[10])
```

[**Observations:**]{.underline}

Based on the EigenVector Centrality, there are a total of **4** business entities with its eigenvalue above the 90th percentile. These business entities are considered the most important/influential business entities in the network.



### 4.7 Visualising Community

```{r}
# Data Preparation
# mc2_edges_aggregated_comm <- mc2_edges_aggregated %>%
#   filter(weight >700) %>%
#   ungroup()
# 
# id1_comm <- mc2_edges_aggregated_comm %>%
#   select(source) %>%
#   rename(id = source)
# id2_comm <- mc2_edges_aggregated_comm %>%
#   select(target) %>%
#   rename(id = target)

# create a new nodes data table derived from the source and target of edge data. This would ensure that only nodes with connections will be included.

# mc2_nodes_extracted_comm <- rbind(id1_comm, id2_comm) %>%
#   distinct()
# 
# mc2_graph_comm <- tbl_graph(nodes = mc2_nodes_extracted_comm,
#                        edges = mc2_edges_aggregated_comm,
#                        directed = TRUE)
# 

```

```{r}
# Create tbl_graph object for the community analysis
# g <- mc2_graph_comm %>%
#   mutate(community = as.factor(group_optimal(weights = weight))) %>%
#   ggraph(layout = "fr") +
#   geom_edge_link(aes(width=weight),
#                  alpha=0.2) +
#   scale_edge_width(range = c(0.1, 5)) +
#   geom_node_point(aes(colour = community))
# 
# g + theme_graph()
```





```{r}
### Exporting to CSV for closer examination
# write_csv(x = final_MC2_nodes_noNA, "data/generated/final_MC2_nodes_noNA.csv")
# write_csv(x = MC2_edges_aggregated, "data/generated/mc2_edges_agg.csv")
# write_csv(x = valid_edges, "data/generated/valid_edges.csv")
```

```{r}
### Exporting to CSV for closer examination
# write_csv(x = mc2_nodes, "data/generated/mc2_nodes.csv")
# write_csv(x = mc2_edges, "data/generated/mc2_edges.csv")
```


```{r}
#| eval: false
# mc2_graph <- read_rds("data/generated/mc2_graph.rds")
# mc2_nodes <- read_rds("data/generated/mc2_nodes.rds")
# mc2_edges <- read_rds("data/generated/mc2_edges.rds")
```

```{r}
#| eval: false
# write_rds(mc2_nodes, "data/generated/mc2_nodes.rds")
# write_rds(mc2_edges, "data/generated/mc2_edges.rds")
# write_rds(mc2_nodes, "data/generated/mc2_nodes_extracted.rds")
# write_rds(mc2_edges, "data/generated/mc2_edges_aggregated.rds")
# write_rds(mc2_graph, "data/generated/mc2_graph.rds")
```

```{r}
#| eval: false
# write_csv(x = nodes_df, "data/generated/nodes_df.csv")
```