---
title: "Take-Home Exercise 02"
author: "Ong Chae Hui"
date: 17 May 2023
date-modified: "`r Sys.Date()`"
execute:
  echo: true
  eval: true
  warning: false
  freeze: auto  
format: 
  html:
    code-fold: false
    code-summary: "Show the codes"
    code-overflow: wrap
    code-block-bg: true
engine: knitr
---

# 1. Overview

With reference to the [Mini-Challenge 2](#0) of [VAST Challenge 2023](#0) and by using appropriate **static and interactive statistical graphics** methods, we will help FishEye identify companies that may be engaged in illegal fishing.

## 1.1. The Task

Use visual analytics to identify temporal patterns for individual entities and between entities in the knowledge graph FishEye created from trade records. Categorize the types of business relationship patterns you find.

## 1.2. Data Source

For this task, we will make use of the *mc2_challenge_graph.json* provided for the data analysis and visualisation.

# 2. Loading and Launching of Required R Packages

The required R library packages are being loaded. For this exercise, we will make use of the following R library packages.

-   **jsonlite**, JSON parser and generator optimized for statistical data and the web.
-   **tidygraph** provides a tidy framework for all things relational (networks/graphs, trees, etc.)
-   **ggraph**, an extension of the ggplot2 API tailored to graph visualizations and provides the same flexible approach to building up plots layer by layer.
-   **visNetwork** for network visualization.
-   **lubridate** is an R package that makes it easier to work with dates and times.
-   **igraph** a library collection for creating and manipulating graphs and analyzing networks.
-   **tidyverse**, a family of modern R packages specially designed to support data science, analysis and communication task including creating static statistical graphs.
-   **DT** provides an R interface to the JavaScript library DataTables that create interactive table on html page.

The code chunk below uses `pacman::p_load()` to check if the above packages are installed. If they are, they will be loaded into the R environment.

```{r}
pacman::p_load(jsonlite, tidygraph, ggraph, visNetwork, lubridate,
               igraph, tidyverse, DT)
```

# 3. Data Preparation

We will first load each of the data files into the environment and perform data wrangling.

## 3.1. Loading and Extracting the Data

Based on the VAST 2023 data notes, column `dataset` will always be 'mc2', to represent this set of data belongs to mini challenge 2. As such, we will not import this column into the R environment.

### 3.1.1. Load main file *mc2_challenge_graph.json*

We will first load in the main file, *mc2_challenge_graph.json*, then extract the nodes and edges (links) information out.

```{r}
mc2 <- fromJSON("data/mc2_challenge_graph.json")
```

#### 3.1.1.1. Extracting the nodes data.frame from mc2

```{r}
mc2_nodes <- as_tibble(mc2$nodes) %>%
  select(id, shpcountry, rcvcountry)
```

#### 3.1.1.2. Extracting the edges (links) data.frame from mc2

```{r}
mc2_edges <- as_tibble(mc2$links) %>%
  select(source, target, arrivaldate, hscode,
         weightkg, valueofgoods_omu, volumeteu,
         valueofgoodsusd)
```

#### 3.1.1.3. Examining the structure of *mc2_nodes* and *mc2_edges* data.frames using `glimpse()` of **dyplr**.

```{r}
glimpse(mc2_nodes)
glimpse(mc2_edges)
```

::: {.callout-tip title="Examination of the data structure"}
1.  There are a number of `chr` data type columns in both *mc2_nodes* and *mc2_edges*, as a good practice, we will trim away any possible leading and trailing white spaces of the data, before we perform any analysis.

2.  The *arrivaldate* has the format of 'YYYY-MM-DD' and is treated as `chr` data type instead of `date` data type.

3.  A closer examination on the columns `valueofgoods_omu`, `volumeteu`, `valueofgoodsusd` columns revealed that there are also a large number of `NA` (missing values) and are deemed as as incomplete. We will drop these columns from analysis.

4.  We will also need to filter out any possible duplicate records by using the `distinct()` function.
:::

#### 3.1.1.4. Perform Data Wrangling for *mc2_edges*

::: {.callout-tip title="Data Preparation for mc2_edges"}
1.  Drop columns `valueofgoods_omu`, `volumeteu` and `valueofgoodsusd` since they are deemed as as incomplete for analysis.

2.  Convert *arrivaldate* from `chr` data type to `date` data type by using `ymd()`.

3.  Extract the *year* component out from *arrivaldate* field with `year()`.

4.  Perform white space trimming for the `chr` columns,to remove any the leading and trailing white spaces with `trimws()`.

5.  Remove any possible duplicate records by using `distinct()`

6.  Based on the data notes provided in the VAST Challenge, `hscode` refers to the Harmonized Commodity Description and Coding System Nomenclature (HS) developed by World Customs Organization (WCO). We will filter all the records based on the hscodes related to the context of the challenge. The relevant hscodes are prefixed with: `301`, `302`, `303`, `304`, `305`, `306`, `307`, `308`, `309`, `1504`, `1603`, `1604`, `1605` and `2301`).

7.  Aggregate the records, by deriving a `weight` column based on the number of records by grouping the `source`, `target`, `hscode` and `year`.
:::

```{r}
# For the edges data frame, we will make use of select() to extract 
# and rearrange the columns.
mc2_edges <- mc2_edges %>%
  select(arrivaldate, source, target, hscode, weightkg) %>%
  mutate(arrivaldate = ymd(arrivaldate)) %>%
  mutate(year = year(arrivaldate)) %>%
  mutate(source = trimws(source)) %>%
  mutate(target = trimws(target)) %>%
  mutate(hscode = trimws(hscode)) %>%
  distinct()
```

```{r}
# List of relevant hscodes related to fishing
rel_hscodes_3 <- c("301", "302", "303", "304", "305",
                   "306", "307", "308", "309")

rel_hscodes_4 <- c("1504", "1603", "1604", "1605", "2301")

# Extract the records with the above 1st 3 or 4 characters of hscodes
# using substr().
mc2_edges_aggregated <- mc2_edges %>%
  filter((substr(hscode, 1, 3) %in% rel_hscodes_3) |
         (substr(hscode, 1, 4) %in% rel_hscodes_4)) %>%
  group_by(source, target, hscode, year) %>%
  summarise(weight = n()) %>%
  filter(source!=target) %>%
  arrange(weight) %>%
  ungroup()
```

#### 3.1.1.5. Perform Data Wrangling for *mc2_nodes*

::: {.callout-tip title="Data Preparation for mc2_nodes"}
The nodes within the node file must be unique and since we have filtered and cleaned the data in *mc2_edges_aggregated*, we will make use of this to extract the nodes that are used here.

`rbind()` is used to combine the data in both `source` and `target` columns of *mc2_edges_aggregated*. We will then extract the unique records to form the nodes data frame.
:::

```{r}
id1 <- mc2_edges_aggregated %>%
  select(source) %>%
  rename(id = source)
id2 <- mc2_edges_aggregated %>%
  select(target) %>%
  rename(id = target)

# create a new nodes data table derived from the source and target of edge data. This would ensure that only nodes with connections will be included.

mc2_nodes_extracted <- rbind(id1, id2) %>%
  distinct()
```

```{r}
# Build tbl_graph using the valid nodes and edges 
mc2_graph <- tbl_graph(nodes = mc2_nodes_extracted,
                       edges = mc2_edges_aggregated,
                       directed = TRUE)
```

# 4. Data Exploration

As part of the data exploration and analysis, we will compute the centrality indices for the nodes and include them as attribute information to the nodes, before plotting them out for visualisation and analysis. We will also rename the `id` column to `label` and create a new column `id` by using the `row_number()` to ease the build of the visualisation graphs using **visNetwork** package.

Standard Binning were being performed on the computed centrality indices for the ease of analysis. The respective indices will be binned into 3 groups, `Low`, `Medium` and `High`.

We will also round up the centrality indices to 3 decimal points for the purpose of analysis.

```{r}
# Renaming the id column to label and
# create a new column, id with the row_number()
mc2_graph <- mc2_graph %>%
  activate(nodes) %>%
  rename(label = id) %>%
  mutate(id=row_number()) 
```

```{r}
mc2_graph <- mc2_graph %>%
  # Compute the degree centrality of each node and bin the scores into logical groups
  mutate(degree_score = centrality_degree()) %>%
  mutate(deg_bin = cut(degree_score, breaks = c(0, 200, 300, Inf),
                       labels = c("Low\n(0-199)", 
                                  "Medium\n(200-299)", 
                                  "High\n(>=300)\n"),  
                       include.lowest = TRUE))  %>%

  # Compute the closeness centrality and bin the scores into logical groups
  mutate(closeness_score = round(centrality_closeness(), digits=3)) %>%
  mutate(close_bin = cut(closeness_score,
                         breaks = c(0, 0.5, 0.8, Inf),
                         labels = c("Low\n(<=0.49)", 
                                    "Medium\n(0.5-0.79)", 
                                    "High\n(>=0.8)\n"), 
                         include.lowest = TRUE)) %>%

  # Compute the betweenness centrality and bin the scores into logical groups
  mutate(betweenness_score = round(centrality_betweenness(), digits = 3)) %>%
  mutate(bet_bin = cut(betweenness_score, 
                       breaks = c(0, 50000, 100000, 500000, Inf),
                       labels = c("Low\n(0-49K)", 
                                  "Medium\n(50K-99K)", 
                                  "High\n(100K-499K)\n",
                                  "Very High\n(>=500K)"),
                       include.lowest = TRUE)) 


# Computing the in-degree and out-degree centrality indices
# Convert to igraph for computing the in-degree and out-degree centrality
igraph_obj <- as.igraph(mc2_graph)

# In-degree centrality
in_degree_centrality <- degree(igraph_obj, mode = "in")

# Out-degree centrality
out_degree_centrality <- degree(igraph_obj, mode = "out")

# Eigenvector centrality
eigen_centrality <- eigen_centrality(igraph_obj, directed = TRUE)$vector


# Assigning in-degree and out-degree centrality as vertex attributes
V(mc2_graph)$in_degree <- in_degree_centrality
V(mc2_graph)$out_degree <- out_degree_centrality
V(mc2_graph)$eigen_score <- round(eigen_centrality, digits=3) 


# Binning the in_degree scores and put as a variable inside mc2_graph
mc2_graph <- mc2_graph %>% 
  mutate(in_bin = cut(in_degree, 
                      breaks = c(0, 300, 600, Inf),
                      labels = c("Low\n(<300)", 
                                 "Medium\n(300-599)", 
                                 "High\n(>=600)"),
                      include.lowest = TRUE)) %>%
  
  # Binning the out_degree scores and put as a variable inside mc2_graph
  mutate(out_bin = cut(out_degree, 
                       breaks = c(0, 2, 300, 500, Inf),
                       labels = c("0-1", "Low\n(2-300)", 
                                  "Medium\n(301-500)", 
                                  "High\n(>500)"),
                       include.lowest = TRUE)) %>%
  
  # Binning the eigenvector scores and put as a variable inside mc2_graph
  mutate(eigen_bin = cut(eigen_score,
                         breaks = c(0, 0.5, 0.8, Inf),
                         labels = c("Low\n(<=0.49)", 
                                    "Medium\n(0.5-0.79)", 
                                    "High\n(>=0.8)\n"), 
                         include.lowest = TRUE)) 

```


Once we have all the centrality indices included into the graph, we will convert the nodes and edges into tibble data frames for easier data manipulation for visualisation purposes. 

```{r}
# Converting the nodes with the centrality measures into a tibble dataframe
nodes_df <- mc2_graph %>%
  activate(nodes) %>%
  as_tibble() 
```

```{r}
# Converting the edges into a tibble dataframe
edges_df <- mc2_graph %>%
  activate(edges) %>%
  as_tibble()
```


## 4.1. Overview of the Network

From the network graph below, each node represents an individual business entity (`label`), which you could select from the dropdown list, to examine the connectivity of this entity with other entities.

[**Design Considerations**]{.underline}

1.  In order not to over clutter the network graph, all edges with weight \<= 50 will be filtered out and not included.

2.  For the ease of selecting a particular entity, a dropdown list with all the entities (nodes) present in the graph is provided. The list is also sorted in ascending order by using `arrange()`.

3.  In addition, directional arrows have also been included on the edges, to identify the in-flow and out-flow edges.

4.  Mouse pointer hover action is also included on the graph so that the user can hover the mouse pointer over the graph to look at the possible different 'groups' of connectivity.

```{r}
# Preparing the data for visualisation
edges <- edges_df %>%
  filter(weight > 50)

nodes <- nodes_df %>%
  filter(id %in% c(edges$from, edges$to)) %>%
  arrange(label)

# Building the network graph using visNetwork package
vis_nw <- visNetwork(nodes, edges,
                     main = "An Overview of the Network Graph") %>%
  visIgraphLayout(layout = "layout_with_fr") %>%
  visLayout(randomSeed = 1234) %>%
  visNodes() %>%
  visOptions(highlightNearest = list(enabled = T, degree = 2, hover = T),
             nodesIdSelection = TRUE) %>%
  visEdges(arrows = "to", smooth = list(enabled = TRUE, type = "curvedCW"))

vis_nw
```

::: {.callout-note title="Observations"}
From the overview network graph, we noticed that some of the nodes in the middle seemed to be denser compared to the rest, indicating that these nodes probably have more connections to the other nodes. We were able to identify the ids of these nodes when we zoom into the graph. We can also look at individual node's connectivity to other nodes by clicking on it or hover it with the mouse pointer. However, this requires the user to maneuver around the graph with great efforts.

We will make use of the different centrality indices computed earlier to uncover more insights in the subsequent sections.
:::


## 4.2. The Important Nodes of the Network - Eigenvector Centrality

Eigenvector centrality index captures the overall importance of a node based on its connections and the importance of those connections in the network. Nodes with high eigenvector centrality are connected to other nodes that are also highly central or influential.

We will attempt to identify the main hub nodes within the network by looking at the nodes with high eigenvector centrality index.

Firstly, we will take a look at the distribution of this centrality index across all the nodes to gain an overview picture of the network.

[**Design Considerations**]{.underline}

In view of the big differentiation in the count for each bin, the `count` for each bin is displayed at the top of each bar for easy reference.

::: panel-tabset
### Distribution of Eigenvector Centrality Index

```{r}
#| echo: false

# Plotting the Distribution for Eigenvector Centrality Index

# Get the count of the records in each bin
nodes_df_eigen_gp <- nodes_df %>%
  group_by(eigen_bin) %>%
  summarise(cnt = n())

# Create a distribution with bar chart using ggplot2
plot_eigen <- ggplot(nodes_df_eigen_gp, aes(x = eigen_bin, y = cnt)) +
  geom_bar(stat = "identity", fill = "deepskyblue3") +
  geom_text(aes(label = cnt), vjust = -0.5, color = "black") +
  labs(x = "\nEigenvector Centrality Index", y = "Count\n", 
       title = "Distribution of Eigenvector Centrality Index") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5)) 

plot_eigen
```

### Code Chunk

```{r}
#| eval: false
#| code-fold: false

# Plotting the Distribution for Eigenvector Centrality Index

# Get the count of the records in each bin
nodes_df_eigen_gp <- nodes_df %>%
  group_by(eigen_bin) %>%
  summarise(cnt = n())

# Create a distribution with bar chart using ggplot2
plot_eigen <- ggplot(nodes_df_eigen_gp, aes(x = eigen_bin, y = cnt)) +
  geom_bar(stat = "identity", fill = "deepskyblue3") +
  geom_text(aes(label = cnt), vjust = -0.5, color = "black") +
  labs(x = "\nEigenvector Centrality Index", y = "Count\n", 
       title = "Distribution of Eigenvector Centrality Index") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5)) 

plot_eigen
```
:::

::: {.callout-note title="Observations from the Distribution of Eigenvector Centrality Index"}
The graph above revealed that there are **4** nodes with eigenvector centrality index of \> 0.5. This means that these nodes are connected to other important nodes in the network. 

A quick examination of the eigenvector centrality index of the nodes revealed that 11,657 out of 11,688 nodes (>99%) have an eigenvector centrality index of <0.1.

For the purpose of visual analysis, we will focus on the 4 nodes with high eigenvector centrality index.
:::


### 4.2.1. Comparing the Different Centrality Indices 

```{r}
# Extracting the top 4 entities with highest centrality indices
nodes_df_eigen_top4 <- nodes_df %>%
  filter(eigen_score >= 0.5) %>%
  select(id, label, eigen_score, eigen_bin, degree_score, deg_bin, 
         in_degree, in_bin, out_degree, out_bin, 
         betweenness_score, bet_bin, closeness_score, close_bin) %>%
  arrange(desc(eigen_score))

datatable(nodes_df_eigen_top4, 
          class="compact",
          caption = "\nTable 1: Business Entities with High Eigenvector Centrality Index\n",
          colnames = c("ID", "Entity", "Eigenvector Centrality Index", 
                       "Eigenvector Centrality Category", 
                       "Degree Centrality Index",
                       "Degree Centrality Category", 
                       "In-Degree Centrality Index",
                       "In-Degree Centrality Category",
                       "Out-Degree Centrality Index",
                       "Out-Degree Centrality Cateogy",
                       "Betweenness Centrality Index",
                       "Betweenness Centrality Category",
                       "Closeness Centrality Index",
                       "Closeness Centrality Category"),
          options = list(
            columnDefs = list(list(className = 'dt-center', 
                                   targets = 14))))
```

### 4.2.2. Eigenvector Centrality Network Graph
```{r}
# get the company names for the edges
edges_df_eigen <- edges_df %>%
  filter(from %in% nodes_df_eigen_top4$id |
         to %in% nodes_df_eigen_top4$id) %>%
  filter(weight > 50)

# build the nodes table
nodes_eigen <- nodes_df %>%
  filter(id %in% c(edges_df_eigen$from, edges_df_eigen$to)) %>%
  rename(group = eigen_bin) %>%
  arrange(label)

visNetwork(nodes_eigen,
           edges_df_eigen,
           main = "Network Graph of the Top 4 Entities with High Eigenvector Centrality") %>%
  visIgraphLayout(layout = "layout_with_fr") %>%
  visLayout(randomSeed = 1234) %>%
  visOptions(highlightNearest = list(enabled = T, degree = 2, hover = T),
             nodesIdSelection = TRUE) %>%
  visNodes(id = nodes_eigen$id, size=10) %>%
 visLegend() %>%  
  visEdges(arrows = "to", 
           smooth = list(enabled = TRUE, 
                         type = "curvedCW"))
```

::: {.callout-note title="Observations"}
Based on the information presented in the DataTable and the visualisation presented in the Network Graph above, we observed that these 4 nodes also have very high number of in-degree centrality index and very low number of out-degree centrality index, suggesting that they are likely to be the fishery wharves/central collection centers within the network. 
:::


## 4.3. Looking at the Degree of Centrality

Degree centrality is a measure of the importance or popularity of a node in a network based on the number of direct connections it has with other nodes in the network. 

::: panel-tabset

### Distribution of Degree Centrality Index
```{r}
#| echo: false

# Plotting the Distribution for Degree Centrality Index
nodes_df_deg_gp <- nodes_df %>%
  group_by(deg_bin) %>%
  summarise(cnt = n())

# Create a bar chart with hover text using ggplot2
plot <- ggplot(nodes_df_deg_gp, aes(x = deg_bin, y = cnt)) +
  geom_bar(stat = "identity", fill = "deepskyblue3") +
  geom_text(aes(label = cnt), vjust = -0.5, color = "black") +
  labs(x = "\nDegree Centrality", y = "Count\n", 
       title = "Distribution of Degree Centrality of the Nodes") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5)) 

plot
```

### Code Chunk
```{r}
#| eval: false
#| code-fold: false

# Plotting the Distribution for Degree Centrality Index
nodes_df_deg_gp <- nodes_df %>%
  group_by(deg_bin) %>%
  summarise(cnt = n())

# Create a bar chart with hover text using ggplot2
plot <- ggplot(nodes_df_deg_gp, aes(x = deg_bin, y = cnt)) +
  geom_bar(stat = "identity", fill = "deepskyblue3") +
  geom_text(aes(label = cnt), vjust = -0.5, color = "black") +
  labs(x = "\nDegree Centrality", y = "Count\n", 
       title = "Distribution of Degree Centrality of the Nodes") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5)) 

plot
```
:::

::: {.callout-note title="Observations from the Distribution of Degree Centrality Index"}
The distribution chart above revealed that more than 99% of the nodes have low degree centrality index. There are **18** nodes with high degree centrality index of \>= 300. This means that these nodes have significantly high number of direct connections to other nodes within the network. 
:::


### 4.3.1. Comparing the Different Centrality Indices
```{r}
# Extract the nodes with high degree centrality index

nodes_df_deg <- nodes_df %>%
  filter(degree_score >= 300) %>%
  select(id, label, degree_score, deg_bin, eigen_score, eigen_bin,
         in_degree, in_bin, out_degree, out_bin,
         betweenness_score, bet_bin, closeness_score, close_bin) %>%  
  arrange(desc(degree_score))

datatable(nodes_df_deg, 
          class="compact",
          caption = "\nTable 2: Business Entities with High Degree Centrality Index\n",
          colnames = c("ID", "Entity", 
                       "Degree Centrality Index",
                       "Degree Centrality Category", 
                       "Eigenvector Centrality Index", 
                       "Eigenvector Centrality Category", 
                       "In-Degree Centrality Index",
                       "In-Degree Centrality Category",
                       "Out-Degree Centrality Index",
                       "Out-Degree Centrality Cateogy",
                       "Betweenness Centrality Index",
                       "Betweenness Centrality Category",
                       "Closeness Centrality Index",
                       "Closeness Centrality Category"),
          options = list(
            columnDefs = list(list(className = 'dt-center', 
                                   targets = 14))))
```

### 4.3.2. Degree Centrality Network Graph
```{r}
# get the entity names for the edges
edges_df_deg <- edges_df %>%
  filter(from %in% nodes_df_deg$id |
         to %in% nodes_df_deg$id) %>%
  filter(weight > 30)

# build the nodes table
nodes_deg <- nodes_df %>%
  filter(id %in% c(edges_df_deg$from, edges_df_deg$to)) %>%
  rename(group = deg_bin) %>%
  arrange(label)

visNetwork(nodes_deg,
           edges_df_deg,
           main = "Entities with High Degree Centrality Index") %>%
  visIgraphLayout(layout = "layout_with_kk") %>%
  visLayout(randomSeed = 1234) %>%
  visOptions(highlightNearest = list(enabled = T, degree = 2, hover = T),
             nodesIdSelection = TRUE) %>%
  visNodes(id = nodes_deg$id, size=10) %>%
  visLegend() %>%  
  visEdges(arrows = "to", 
           smooth = list(enabled = TRUE))
```

::: {.callout-note title="Observations"}
Based on the information presented in the DataTable and Network Graph, we noticed that these nodes generally have a high number of outgoing connections (>300 each), and very low number of incoming connections (highest at 24 incoming connections). This suggest these nodes are likely to be the bigger fishing vessels or distributors. 
:::

## 4.4. Looking at the In-Degree Centrality

In-degree centrality is a measure of centrality in a network that focuses on incoming connections to a node. Nodes with high in-degree centrality have a larger number of connections pointing towards them, indicating that they receive a lot of resources from other nodes. 

::: panel-tabset
### Distribution for In-Degree Centrality Index

```{r}
#| echo: false

# Plotting the Distribution for In-Degree centrality Index
nodes_df_in <- nodes_df %>%
  group_by(in_bin) %>%
  summarise(cnt = n())

# Create a bar chart with hover text using ggplot2
plot_in <- ggplot(nodes_df_in, aes(x = in_bin, y = cnt)) +
  geom_bar(stat = "identity", fill = "deepskyblue3") +
  geom_text(aes(label = cnt), vjust = -0.5, color = "black") +
  labs(x = "\nIn-Degree Centrality", y = "Count\n", 
       title = "Distribution of In-Degree Centrality of the Nodes") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5)) 

plot_in
```

### Code Chunk

```{r}
#| eval: false
#| code-fold: false

# Plotting the Distribution for In-Degree centrality Index
nodes_df_in <- nodes_df %>%
  group_by(in_bin) %>%
  summarise(cnt = n())

# Create a bar chart with hover text using ggplot2
plot_in <- ggplot(nodes_df_in, aes(x = in_bin, y = cnt)) +
  geom_bar(stat = "identity", fill = "deepskyblue3") +
  geom_text(aes(label = cnt), vjust = -0.5, color = "black") +
  labs(x = "\nIn-Degree Centrality", y = "Count\n", 
       title = "Distribution of In-Degree Centrality of the Nodes") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5)) 

plot_in
```
:::

::: {.callout-note title="Observations from the Distribution of In-Degree Centrality Index"}
It is observed that there are **27** nodes with significantly high in-degree centrality index (\>=600), which are likely to be the main resource collection points.
:::

### 4.4.1. Comparing the Different Centrality Indices

```{r}
# Extracting the top 10 entities with highest in-degree centrality
nodes_df_in_top <- nodes_df %>%
  filter(in_degree >= 600) %>%
  select(id, label, in_degree, in_bin, eigen_score, eigen_bin,
         degree_score, deg_bin, betweenness_score, bet_bin, 
         closeness_score, close_bin, out_degree, out_bin) %>%
  arrange(desc(in_degree))

top_10_in <- head(nodes_df_in_top,10)
  
datatable(top_10_in, 
          class="compact",
          caption = "\nTable 3: Top 10 Business Entities with In-Degree Centrality Index\n",
          colnames = c("ID", "Entity", "In-Degree Centrality Index",
                       "In-Degree Centrality Category",
                       "Eigenvector Centrality Index", 
                       "Eigenvector Centrality Category", 
                       "Degree Centrality Index",
                       "Degree Centrality Category", 
                       "Betweenness Centrality Index",
                       "Betweenness Centrality Category",
                       "Closeness Centrality Index",
                       "Closeness Centrality Category",
                       "Out-Degree Centrality Index",
                       "Out-Degree Centrality Cateogy"),
          options = list(
            columnDefs = list(list(className = 'dt-center', 
                                   targets = 14))))

```


### 4.4.2. In-Degree Centrality Network Graph
```{r}
# get the entity names for the edges
edges_df_in <- edges_df %>%
  filter(from %in% top_10_in$id |
         to %in% top_10_in$id) %>%
  filter(weight > 80)

# build the nodes table
nodes_in <- nodes_df %>%
  filter(id %in% c(edges_df_in$from, edges_df_in$to)) %>%
  rename(group = in_bin) %>%
  arrange(label)

visNetwork(nodes_in,
           edges_df_in,
           main = "Entities with High In-Degree Centrality Index") %>%
  visIgraphLayout(layout = "layout_with_fr") %>%
  visLayout(randomSeed = 1234) %>%
  visOptions(highlightNearest = list(enabled = T, degree = 2, hover = T),
             nodesIdSelection = TRUE) %>%
  visNodes(id = nodes_in$id, size=10) %>%
  visLegend() %>%  
  visEdges(arrows = "to", 
           smooth = list(enabled = TRUE, 
                         type = "curvedCW"))
```

::: {.callout-note title="Observations"}
High in-degree centrality index suggests that these nodes are likely to be the fishery wharves/collection centres for the fishing vessels. It is noted that some of these nodes also have high eigenvector centrality index, indicating tha they are one of the key nodes within the network.

Most of these nodes have low values for degree centrality, out-degree centrality and closeness centrality indices.

:::


## 4.5. Looking at the Out-Degree Centrality

Out-degree centrality is a measure of centrality in a network that focuses on outgoing connections from a node. Nodes with high out-degree centrality have a larger number of connections pointing away from them, indicating that they have a greater reach and influence over other nodes. 

::: panel-tabset
### Distribution for Out-Degree Centrality Index

```{r}
#| echo: false

# Plotting the Distribution for Out-Degree centrality Index
nodes_df_out <- nodes_df %>%
  group_by(out_bin) %>%
  summarise(cnt = n())

# Create a bar chart with hover text using ggplot2
plot_in <- ggplot(nodes_df_out, aes(x = out_bin, y = cnt)) +
  geom_bar(stat = "identity", fill = "deepskyblue3") +
  geom_text(aes(label = cnt), vjust = -0.5, color = "black") +
  labs(x = "\nOut-Degree Centrality", y = "Count\n", 
       title = "Distribution of Out-Degree Centrality of the Nodes") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5)) 

plot_in
```

### Code Chunk

```{r}
#| eval: false
#| code-fold: false

# Plotting the Distribution for Out-Degree Centrality Index
nodes_df_out <- nodes_df %>%
  group_by(out_bin) %>%
  summarise(cnt = n())

# Create a bar chart with hover text using ggplot2
plot_in <- ggplot(nodes_df_out, aes(x = out_bin, y = cnt)) +
  geom_bar(stat = "identity", fill = "deepskyblue3") +
  geom_text(aes(label = cnt), vjust = -0.5, color = "black") +
  labs(x = "\nOut-Degree Centrality", y = "Count\n", 
       title = "Distribution of Out-Degree Centrality of the Nodes") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5)) 

plot_in
```
:::

::: {.callout-note title="Observations from the Distribution of Out-Degree Centrality Index"}
Majority of the entities in the network have low number of out-degree centrality index, which suggest that they are likely to be the fishing vessels within the network, contributing to one of the major fishery wharves/collection centres.

It is observed that there are **18** nodes with significantly high out-degree centrality index (\>300), which we will study them in more details.
:::

### 4.5.1. Comparing the Different Centrality Indices

```{r}
# Extracting the top companies with highest out-degree centrality
nodes_df_out <- nodes_df %>%
  filter(out_degree > 300) %>%
  select(id, label, out_degree, out_bin, eigen_score, eigen_bin, 
         degree_score, deg_bin, betweenness_score, bet_bin, 
         closeness_score, close_bin, in_degree, in_bin) %>%
  arrange(desc(out_degree))


datatable(nodes_df_out, 
          colnames = c("ID", "Entity", "Out-Degree Centrality Index",
                       "Out-Degree Centrality Cateogy",
                       "Eigenvector Centrality Index", 
                       "Eigenvector Centrality Category", 
                       "Degree Centrality Index",
                       "Degree Centrality Category", 
                       "Betweenness Centrality Index",
                       "Betweenness Centrality Category",
                       "Closeness Centrality Index",
                       "Closeness Centrality Category",
                       "In-Degree Centrality Index",
                       "In-Degree Centrality Category"),
          options = list(
            columnDefs = list(list(className = 'dt-center', 
                                   targets = 14))))

```

### 4.5.2. Out-Degree Centrality Network Graph
```{r}
# get the company names for the edges
edges_df_out <- edges_df %>%
  filter(from %in% nodes_df_out$id |
         to %in% nodes_df_out$id) %>%
  filter(weight > 30)

# build the nodes table
nodes_out <- nodes_df %>%
  filter(id %in% c(edges_df_out$from, edges_df_out$to)) %>%
  rename(group = out_bin) %>%
  arrange(label)

visNetwork(nodes_out,
           edges_df_out,
           main = "Entities with High Out-Degree Centrality Index") %>%
  visIgraphLayout(layout = "layout_with_fr") %>%
  visLayout(randomSeed = 1234) %>%
  visOptions(highlightNearest = list(enabled = T, degree = 2, hover = T),
             nodesIdSelection = TRUE) %>%
  visNodes(id = nodes_out$id, size=10) %>%
  visLegend() %>%  
  visEdges(arrows = "to", 
           smooth = list(enabled = TRUE, 
                         type = "curvedCW"))
```

::: {.callout-note title="Observations"}
The entity with the highest out-degree centrality index, The Salty Dog Limited Liability Company, provides resources to other nodes with low value of out-degree centrality index.
:::

## 4.6. Eigenvector Centrality

Eigenvector centrality is a measure to indicate the importance or influence of a node to the other nodes. It considers both the number of connections a node has and the importance of those connections. Nodes with high eigen centrality are not only connected to many other nodes but are also connected to nodes that have high eigen centrality.

### 4.6.1. Data Preparation

```{r}
mc2_edges_aggregated_eigen <- mc2_edges_aggregated %>%
  filter(weight >80) %>%
  ungroup()

id1_eigen <- mc2_edges_aggregated_eigen %>%
  select(source) %>%
  rename(id = source)
id2_eigen <- mc2_edges_aggregated_eigen %>%
  select(target) %>%
  rename(id = target)

# create a new nodes data table derived from the source and target of edge data. This would ensure that only nodes with connections will be included.

mc2_nodes_extracted_eigen <- rbind(id1_eigen, id2_eigen) %>%
  distinct()

mc2_graph_eigen <- tbl_graph(nodes = mc2_nodes_extracted_eigen,
                       edges = mc2_edges_aggregated_eigen,
                       directed = TRUE)

```

### 4.6.2. Plotting the Eigenvector Network Graph

```{r}
quantile_graph <- quantile(eigen_centrality(mc2_graph_eigen)$vector,
                           probs = seq(0, 1, 1/10))

V(mc2_graph_eigen)$size = eigen_centrality(mc2_graph_eigen)$vector

mc2_graph_aggregated_eigen <- delete_vertices(mc2_graph_eigen,
                                        V(mc2_graph_eigen)[size <                                                        quantile_graph[10]])

set.seed (1234)

layout1 <- layout_with_kk(mc2_graph_aggregated_eigen)

#identify top 10% of the new vertices
quantile_graph_aggregated <- quantile(V(mc2_graph_aggregated_eigen)$size,
                                      probs = seq(0, 1, 1/10))

# color yellow if vertices is top 10%
V(mc2_graph_aggregated_eigen)$color <- ifelse (V(mc2_graph_aggregated_eigen)$size >
                                           quantile_graph_aggregated[10],
                                         "darkgoldenrod3", "azure3")

# Greying out the edges so that the yellow nodes will stand out in the graph
E(mc2_graph_aggregated_eigen)$color <- "grey"

#Increase the size of nodes based on their centrality score, only those with high score will be visible
V(mc2_graph_aggregated_eigen)$size <- V(mc2_graph_aggregated_eigen)$size/0.065

plot(mc2_graph_aggregated_eigen, edge.arrow.size=0.25,edge.arrow.mode = "-",
     main = "Most Important/Influential Business Entities in the Network",
     width=30, height=12)
```

```{r}
  vertex_attr(mc2_graph_aggregated_eigen,
              index = V(mc2_graph_aggregated_eigen)$size*0.065 >
                quantile_graph_aggregated[10])
```

[**Observations:**]{.underline}

Based on the EigenVector Centrality, there are a total of **4** business entities with its eigenvalue above the 90th percentile. These business entities are considered the most important/influential business entities in the network.

### 4.7 Visualising Community

```{r}
# Data Preparation
# mc2_edges_aggregated_comm <- mc2_edges_aggregated %>%
#   filter(weight >700) %>%
#   ungroup()
# 
# id1_comm <- mc2_edges_aggregated_comm %>%
#   select(source) %>%
#   rename(id = source)
# id2_comm <- mc2_edges_aggregated_comm %>%
#   select(target) %>%
#   rename(id = target)

# create a new nodes data table derived from the source and target of edge data. This would ensure that only nodes with connections will be included.

# mc2_nodes_extracted_comm <- rbind(id1_comm, id2_comm) %>%
#   distinct()
# 
# mc2_graph_comm <- tbl_graph(nodes = mc2_nodes_extracted_comm,
#                        edges = mc2_edges_aggregated_comm,
#                        directed = TRUE)
# 

```

```{r}
# Create tbl_graph object for the community analysis
# g <- mc2_graph_comm %>%
#   mutate(community = as.factor(group_optimal(weights = weight))) %>%
#   ggraph(layout = "fr") +
#   geom_edge_link(aes(width=weight),
#                  alpha=0.2) +
#   scale_edge_width(range = c(0.1, 5)) +
#   geom_node_point(aes(colour = community))
# 
# g + theme_graph()
```

```{r}
### Exporting to CSV for closer examination
# write_csv(x = final_MC2_nodes_noNA, "data/generated/final_MC2_nodes_noNA.csv")
# write_csv(x = MC2_edges_aggregated, "data/generated/mc2_edges_agg.csv")
# write_csv(x = valid_edges, "data/generated/valid_edges.csv")
```

```{r}
### Exporting to CSV for closer examination
# write_csv(x = mc2_nodes, "data/generated/mc2_nodes.csv")
# write_csv(x = mc2_edges, "data/generated/mc2_edges.csv")
```

```{r}
#| eval: false
# mc2_graph <- read_rds("data/generated/mc2_graph.rds")
# mc2_nodes <- read_rds("data/generated/mc2_nodes.rds")
# mc2_edges <- read_rds("data/generated/mc2_edges.rds")
```

```{r}
#| eval: false
# write_rds(mc2_nodes, "data/generated/mc2_nodes.rds")
# write_rds(mc2_edges, "data/generated/mc2_edges.rds")
# write_rds(mc2_nodes, "data/generated/mc2_nodes_extracted.rds")
# write_rds(mc2_edges, "data/generated/mc2_edges_aggregated.rds")
# write_rds(mc2_graph, "data/generated/mc2_graph.rds")
```

```{r}
#| eval: false
# write_csv(x = nodes_df, "data/generated/nodes_df.csv")
```
